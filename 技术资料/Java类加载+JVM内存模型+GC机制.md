个人认为 JVM的理解

其实

一部分是Java类的编译，加载，执行机制。

另一部分就是Java虚拟机内存模型和GC机制。

## Java虚拟机内存模型

- 前言

  ```
  Java虚拟机再执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域
  这些数据区域都有各自的用途，以及创建和销毁的时间，并且他们可以分为两种类型：
  1.线程共享的数据区包括方法区(运行时的常量值）和堆
  2.线程私有的数据区包括虚拟机、本地方法栈和程序计数器。
  ```

  ![JVMåå­æ¨¡å.png-56.5kB](http://static.zybuluo.com/Rico123/wozzd000rzpwwpz4eqi0xf1j/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

- 和计算机虚拟内存模型要区分开

  虚拟内存模型是针对进程的

  常见的linux虚拟内存模型

  进程虚拟存储器：程序文件，已初始化的数据，未初始化的数据，运行时堆（这是进程虚拟存储器）

- 程序计数器，记录线程执行到哪了，计数器记录的是正在执行的字节码指令的地址✅

  ```
  多线程抢夺计算资源，所以要时间片轮询实现并发。
  因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。记录执行到哪了。
  程序计数器是线程私有的一块较小的内存空间，其可以看做是当前线程所执行的字节码的行号指示器。
  如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的字节码指令的地址；
  如果正在执行的是 Native 方法，则计数器的值为空。
  //native方法的意思就是该方法 由非java语言实现，非java代码的接口，这时候程序计数器就为空了。
  - 程序计数器是唯一一个没有规定任何OutOfMemorryError的区域。
  ```

- 虚拟机栈 java方法执行的内存模型，线程私有✅

  ```
  虚拟机栈描述的是Java方法执行的内存模型，是线程私有的。
  每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而且 每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。
  每个方法再执行的时候都会创建一个栈帧，局部变量表主要存放一些基本类型的变量和对象句柄，他们可以是方法参数，也可以是方法的局部变量。
  
  虚拟机栈有两种异常情况
  1.StackOverflowError和OutOfMemorryError。我们知道，一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（比如递归多少层，或嵌套调用多少层其他方法）若线程请求的栈深度大于虚拟机允许的深度，则抛出StackOverFlowError的异常。
  此外栈的大小是固定的，也可以是动态扩展的，若虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存
  （比如没有足够的内存为一个新创建，则抛出OutofMemorryError异常
  ```

- 本地方法栈 ✅

  虚拟机栈，栈帧结构：局部变量表，动态链接方法，操作数栈，返回地址。

  方法执行的时候的返回地址，其实就是调用关系，一个方法call了一个方法，方法执行完怎么回去，就是这个返回地址。

  ```
  本地方法栈和Java虚拟栈十分相似，也是线程私有的，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行Native方法。Native Method Stack。
  与虚拟机栈一致，也会抛出上述两种异常。
  ```

- 线程共享数据区 ✅

  ```
  线程共享的数据区 具体包括 Java堆 和 方法区 两个区域
  ```

- Java堆

  所有的对象实例都在此分配空间，所以Java堆一定是线程共享的，并且对内存消耗较大，因此不一定非要是物理连续， 另外Java堆在实现的时候，一定要是可扩展的，否则就会抛出异常，因为所有对象实例都在此分配空间，所以也是GC的重灾区，也叫GC堆

  ```
  Java堆的唯一目的就是存放对象实例，几乎所有的对象实例（和数组）都在这里分配内存。
  
  Java堆是线程共享的（这一块内存区域是共享的，不是说类的对象是共享的），类的对象从中分配空间，这些对象通过new、newarray、 anewarray 和 multianewarray 等指令建立，它们不需要程序代码来显式的释放。
  
  由于Java堆唯一目的就是用来存放对象实例，因此其也是垃圾收集器管理的主要区域，故也称为称为 GC堆。从内存回收的角度看，由于现在的垃圾收集器基本都 采用分代收集算法，所以为了方便垃圾回收Java堆还可以分为 新生代 和 老年代 。
  
  Java堆可以物理上不连续，只要逻辑上连续即可。
  
  
  而且，Java堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx(最大堆容量) 和 -Xms(最小堆容量)控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出 OutOfMemoryError 异常。 
  
  ```

- TLAB Sun Hotspot JVM

  ```
  Thread Local Allocation Buffer
  Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间 TLAB，其大小由JVM根据运行的情况计算而得。
  在TLAB上分配对象时不需要加锁(相对于CAS配上失败重试方式 )，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。
  
  这也是共享区的问题，Java堆的线程安全问题
  虚拟机为新生对象分配内存时，需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。
  
  在分配内存时候的线程安全问题，需要对指针进行加锁。
  
  TLAB 的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存 TLAB，哪个线程需要分配内存就在自己的TLAB上进行分配，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。
  CAS是在里面怎么用的，
  ```

  

- 方法区

  ```
  方法区与java堆一样，也是线程共享的，并且不需要物理上连续的内存，其用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。 而java堆，是动态分配的，所以 在类加载器的时候，类信息首先被放在方法区内。
  方法区通常和永久区（Perm）关联在一起，但永久代和方法区不是一个概念，只是有的虚拟机用永久代来实现方法去，这样就可以用永久代GC来管理方法区，
  
  ```

- 方法区—运行时常量池

  ```
  运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种 字面量 和 符号引用。其中，字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。因此String是被声明为final的，所以改变的时候都是申请一个新的空间再copy内容过去。
  
  ```

  

## JavaGC机制

- 垃圾回收机制的意义 ✅

  ```
  分代收集算法简介：
  新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，对象就会被移入老年代。新生代又可进一步细分为 eden、survivorSpace0 和 survivorSpace1。刚创建的对象都放入 eden，s0 和 s1 都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代。
  
  
  Java技术体系中所提倡的 自动内存管理 最终可以归结为自动化地解决了两个问题：给对象分配内存 以及回收分配给对象的内存，而且这两个问题针对的内存区域就是Java内存模型中的堆区
  Java垃圾回收机制要考虑的问题十分复杂
  1.哪些内存需要回收（对象是否可以被回收的两种经典算法：引用计数法 和 可达性分析算法）
  2.什么时候回收（堆的新生代，老生代，永久代的垃圾回收机制，MinorGC和FullGC）
  3.如何回收？（三种经典垃圾回收算法（标记清除法，复制算法，标记整理算法）以及分代收集器
  
  Java使用一系列软指针来跟踪对象的各个引用，并用一个对象表将这些软指针映射为对象的引用。之所以称为软指针，是因为这些指针并不直接指向对象，而是指向对象的引用。
  使用软指针，Java的GC能够以单独的线程运行在后台，并依次检查每个对象，通过更改
  
  ```

- 垃圾回收综述 ✅

  ```
  JVM由于要执行GC而停止了应用程序的执行称之为Stop-the-World，该情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。
  ```

  

- 可达性算法：判断对象的引用链是否可达

  ```
  可达性算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。
  可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）
  
  当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。
  可以作为GCRoot的对象包括
  1.虚拟机栈
  2.方法区中类静态属性引用的对象
  3.方法区中常量引用对象
  4.本地方法栈中Native方法引用对象
  ```

- 引用计数法

  ```
  引用计数法是通过判断对象的引用数量来决定对象是否可以被回收。
  引用计数算法是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数。
  有新的引用变量引用这个对象的时候 引用计数器+1
  但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。
  可以被收集的标准：任何引用计数器为0的对象
  
  但是引用计数法也有问题，就是循环引用的问题，如果两个对象循环引用，同时没有其他外部对象引用它俩
  其实这两个对象是不可达的，如果用可达性算法分析的话
  ```

- 垃圾回收算法：

  ```
  标记清除法：
  标记-清除算法分为标记和清除两个阶段。
  该算法首先从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中的未被标记的对象进行回收
  
  但是标记清除法也有不足
  一个是 效率问题，标记和清除两个过程的效率都不高，至少遍历一遍，是n的复杂度
  另一个就是 空间问题，标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此会有大量不连续的内存碎片产生，这样如果大的对象需要内存分配的话，不得不提前触发另一次GC
  ```

- 复制算法 其实有点像操作系统的分段内存管理

  ```
  复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
  
  ```

  

- 程序员不可以强制GC发生，但是可以建议系统GC 调用System.gc()方法

  ```
  
  ```



## 类加载机制

其实关于类加载机制，有这么三个问题

```
虚拟机什么时候才会加载class文件，并初始化类呢？类加载和初始化的时机
虚拟机如何加载一个class文件？ Java类加载的方式的问题，具体的话就使类加载器，双亲委派机制（为什么，有什么好处）。
虚拟机加载一个class文件，要经历哪些具体步骤的问题。（类加载过程和步骤的问题）
```



- 双亲委派模型，为什么使用双亲委派模型

  ```
  双亲委派模型很好地解决了类加载器的统一加载问题：越基础的类由越上层的加载器进行加载，进而保证Java类型体系中最基础的行为，防止应用程序变得混乱，如果可以任意方向执行类加载器，比如依赖类没有加载反倒先加载了子类，并且还可以防止重复加载的问题。
  使用双亲委派模型的原因：java类随着其类加载器一起具备了一种带有优先级的层级关系
  比如，java.lang.Object 类总是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类型（是否是同一类型由类加载器与类本身共同决定）。
  
  使用双亲委派模型原因:java类随着其类加载器一起具备了一种带有优先级的层次关系.例如 java.lang.Object,无论哪一个类加载器要加载该类,最终都是委托给处于顶端的启动类加载器,因此object在程序的各种类加载器环境中都是同一个类.相反如果没有使用双亲委派模型,那么假如用户自定义了一个称为java.lang.Object的类,并放在classPath中,那么系统将会出现多个不同的Object类,
  
  ```

  

![èªå®ä¹ç±"å è½½å¨å è½½ç±"çè¿ç¨-54.2kB](http://static.zybuluo.com/Rico123/z3hgytno2ijb152rdy2bd4pv/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E8%BF%87%E7%A8%8B)



- 双亲委派模型描述

  ```
  自底向上加载，子类需要用到某个class的时候，自底向上查找，看父类类加载器是否加载，查到了则返回相应类实例的引用，没有查到就bootstrapClassLoader就会抛出异常并且 自顶而下尝试加载，
  ```

  

- 关于自定义类加载器

  ```
  加密：java代码可以轻易的被反编译，如果你需要对你的代码进行加密以防止反编译，可以先将编译后的代码用加密算法加密，类加密后就不能再使用自带的类加载器了，编译->加载(类加载器，将一个类从二进制字节流读入JVM内部，并存储在运行时内存区的方法区里->然后将其转换为一个与目标类型对应的java.lang.class对象实例
  ```

  