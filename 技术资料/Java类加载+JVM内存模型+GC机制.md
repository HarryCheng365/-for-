个人认为 JVM的理解

其实

一部分是Java类的编译，加载，执行机制。

另一部分就是Java虚拟机内存模型和GC机制。

## Java虚拟机内存模型

- 前言

  ```
  Java虚拟机再执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域
  这些数据区域都有各自的用途，以及创建和销毁的时间，并且他们可以分为两种类型：
  1.线程共享的数据区包括方法区(运行时的常量值）和堆
  2.线程私有的数据区包括虚拟机、本地方法栈和程序计数器。
  ```

  ![JVMåå­æ¨¡å.png-56.5kB](http://static.zybuluo.com/Rico123/wozzd000rzpwwpz4eqi0xf1j/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

- 和计算机虚拟内存模型要区分开

  虚拟内存模型是针对进程的

  常见的linux虚拟内存模型

  进程虚拟存储器：程序文件，已初始化的数据，未初始化的数据，运行时堆（这是进程虚拟存储器）

- 程序计数器

  ```
  多线程抢夺计算资源，所以要时间片轮询实现并发。
  因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。记录执行到哪了。
  程序计数器是线程私有的一块较小的内存空间，其可以看做是当前线程所执行的字节码的行号指示器。
  如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的字节码指令的地址；
  如果正在执行的是 Native 方法，则计数器的值为空。
  - 程序计数器是唯一一个没有规定任何OutOfMemorryError的区域。
  ```

- 虚拟机栈

  ```
  虚拟机栈描述的是Java方法执行的内存模型，是线程私有的。
  每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而且 每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。
  每个方法再执行的时候都会创建一个栈帧，局部变量表主要存放一些基本类型的变量和对象句柄，他们可以是方法参数，也可以是方法的局部变量。
  
  虚拟机栈有两种异常情况
  1.StackOverflowError和OutOfMemorryError。我们知道，一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（比如递归多少层，或嵌套调用多少层其他方法）若线程请求的栈深度大于虚拟机允许的深度，则抛出StackOverFlowError的异常。
  此外栈的大小是固定的，也可以是动态扩展的，若虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存
  （比如没有足够的内存为一个新创建，则抛出
  ```

- 本地方法栈

  虚拟机栈，栈帧结构：局部变量表，动态链接方法，操作数栈，返回地址。

  方法执行的时候的返回地址，其实就是调用关系，一个方法call了一个方法，方法执行完怎么回去，就是这个返回地址。

  ```
  本地方法栈和Java虚拟栈十分相似，也是线程私有的，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行Native方法。
  与虚拟机栈一致，也会抛出上述两种异常。
  ```

- 线程共享数据区✅

  ```
  线程共享的数据区 具体包括 Java堆 和 方法区 两个区域
  ```

- Java堆

  ```
  Java堆的唯一目的就是存放对象实例，几乎所有的对象实例（和数组）都在这里分配内存。
  
  Java堆是线程共享的（这一块内存区域是共享的，不是说类的对象是共享的），类的对象从中分配空间，这些对象通过new、newarray、 anewarray 和 multianewarray 等指令建立，它们不需要程序代码来显式的释放。
  
  由于Java堆唯一目的就是用来存放对象实例，因此其也是垃圾收集器管理的主要区域，故也称为称为 GC堆。从内存回收的角度看，由于现在的垃圾收集器基本都 采用分代收集算法，所以为了方便垃圾回收Java堆还可以分为 新生代 和 老年代 。
  
  Java堆可以物理上不连续，只要逻辑上连续即可。
  
  而且，Java堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx(最大堆容量) 和 -Xms(最小堆容量)控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出 OutOfMemoryError 异常。 
  ```

- TLAB Sun Hotspot JVM

  ```
  Thread Local Allocation Buffer
  Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间 TLAB，其大小由JVM根据运行的情况计算而得。
  在TLAB上分配对象时不需要加锁(相对于CAS配上失败重试方式 )，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。
  
  这也是共享区的问题，Java堆的线程安全问题
  虚拟机为新生对象分配内存时，需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。TLAB 的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存 TLAB，哪个线程需要分配内存就在自己的TLAB上进行分配，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。
  
  ```

  

- 方法区

  ```
  方法区与java堆一样，也是线程共享的，并且不需要物理上连续的内存，其用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
  方法区通常和永久区（Perm）关联在一起，但永久代和方法区不是一个概念，只是有的虚拟机用永久代来实现方法去，这样就可以用永久代GC来管理方法区，
  
  ```

- 方法区—运行时常量池

  ```
  运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种 字面量 和 符号引用。其中，字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。因此String是被声明为final的，所以改变的时候都是申请一个新的空间再copy内容过去。
  
  ```

  

## JavaGC机制

- 垃圾回收机制的意义 ✅

  ```
  分代收集算法简介：
  新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，对象就会被移入老年代。新生代又可进一步细分为 eden、survivorSpace0 和 survivorSpace1。刚创建的对象都放入 eden，s0 和 s1 都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代。
  
  
  Java技术体系中所提倡的 自动内存管理 最终可以归结为自动化地解决了两个问题：给对象分配内存 以及回收分配给对象的内存，而且这两个问题针对的内存区域就是Java内存模型中的堆区
  Java垃圾回收机制要考虑的问题十分复杂
  1.哪些内存需要回收（对象是否可以被回收的两种经典算法：引用计数法 和 可达性分析算法）
  2.什么时候回收（堆的新生代，老生代，永久代的垃圾回收机制，MinorGC和FullGC）
  3.如何回收？（三种经典垃圾回收算法（标记清楚法，复制算法，标记整理算法）
  
  Java使用一系列软指针来跟踪对象的各个引用，并用一个对象表将这些软指针映射为对象的引用。之所以称为软指针，是因为这些指针并不直接指向对象，而是指向对象的引用。
  使用软指针，Java的GC能够以单独的线程运行在后台，并依次检查每个对象，通过更改
  
  ```

- 垃圾回收综述 ✅

  ```
  JVM由于要执行GC而停止了应用程序的执行称之为Stop-the-World，该情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。
  ```

  

- 可达性算法：判断对象的引用链是否可达

  ```
  可达性算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。
  可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）
  
  当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。
  可以作为GCRoot的对象包括
  1.虚拟机栈
  2.方法区中类静态属性引用的对象
  3.方法区中常量引用对象
  4.本地方法栈中Native方法引用对象
  ```

  

- 程序员不可以强制GC发生，但是可以建议系统GC 调用System.gc()方法

  ```
  
  ```




## 类加载机制

- 双亲委派模型

  ```
  双亲委派模型很好地解决了类加载器的统一加载问题：越基础的类由越上层的加载器进行加载，进而保证Java类型体系中最基础的行为，防止应用程序变得混乱。比如，java.lang.Object 类总是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类型（是否是同一类型由类加载器与类本身共同决定）。
  ```

  

![èªå®ä¹ç±"å è½½å¨å è½½ç±"çè¿ç¨-54.2kB](http://static.zybuluo.com/Rico123/z3hgytno2ijb152rdy2bd4pv/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E8%BF%87%E7%A8%8B)

