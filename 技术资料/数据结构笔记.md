- 给定入栈序列，判断给出的出栈序列可不可能||求出所有的出栈序列||给定树的结点，求有多少种树？

# 卡特兰数

```
对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。

在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。

不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。

反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。

因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。

显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)。

还让我们用C++写了当时
```

# 数据结构：

```
基本策略：
1.Leetcode刷题，根据Leetcode给出的题库
2.一天 计网||数据库||多线程编程||Spring相关 换着来 一天一个专题
3.博客也不要拉下，阿里大神的算法博客，多整理笔记，精神高度集中其他课就不看了
4.最后开始看面试70题，面试100题之类的查漏补缺

```



## 编程常用容器类：

- Vector Vector就是队列 可以这么说

  ```Java
  Vector vq= new Vector();
  vq.addElement(months[i]+" ");
  vq.removeElement(vq.firstElement());//先进先出
  ```

  

- List集合去重

  https://www.cnblogs.com/cainiao-Shun666/p/7911142.html

- HashMap如何遍历

  https://blog.csdn.net/gary0917/article/details/79783713

- Java中 List Integer 和int int[]的转换

  <https://blog.csdn.net/zx000003/article/details/82691578>

- 栈Stack

  ```
  Stack底层 用数组，可变数组，链表都可以实现
  ```

## 字符串subString()

- substring(int beginIndex)

  是截取扔掉前beginIndex个 留下beginIndex后的字符

- substring(int beginIndex,int endIndex)

  是截取beginIndex到endIndex中间这么多个

# 数组与链表：单/双向链表，跳舞链 

### 跳表

​	跳表是在链表的基础上，针对链表查询速度很慢，而提出的构建多级查询链表的一种数据结构。其结构如下：

![](./assets/%E8%B7%B3%E8%A1%A8.png)

​	其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。

跳表具有如下性质：

- 由很多层结构组成
- 每一层都是一个有序的链表
- 最底层(Level 1)的链表包含所有元素
- 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。
- 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。









# 栈与队列

# 树与图：最近公共祖先、并查集

### 堆（最大堆、最小堆）

堆的底层结构为完全二叉树，因此常使用数组来存储。//从数组怎么复原完全二叉树

### 最大堆

##### 定义

​	根结点的键值是所有堆结点键值中最大者，且每个结点的值都比其孩子的值大。

##### 存储特点

​	最大堆通常都是一棵完全二叉树，因此我们使用数组的形式来存储最大堆的值，从1号单元开始存储，因此父结点跟子结点的关系就是两倍的关系。

​	即：heap[father * 2] = heap[leftChild];  heap[father * 2 + 1] = heap[rightChild];

##### 最大堆的初始化

1. 方法一：插入法

   从空堆开始，依次插入每一个结点，直到所有的结点全部插入到堆为止。 
   时间：O(n*log(n)) 

2. 方法二：调整法

   ​	序列对应一个完全二叉树；从最后一个分支结点（n div 2）开始，到根（1）为止，依次对每个分支结点进行调整（下沉），以便形成以每个分支结点为根的堆，当最后对树根结点进行调整后，整个树就变成了一个堆。 
   ​	时间：O(n) 

   ​	对如图的序列，要使其成为堆，我们从最后一个分支结点(10/2)，其值为72开始，依次对每个分支节点53，18，36，45进行调整(下沉)：

   ![](./assets/最大堆创建过程1.png)

   ![](./assets/最大堆创建过程2.png)

   ![](./assets/最大堆创建过程3.png)

   注释：如何获取相应数组序列？

   方法是依次将堆的根节点的小数记下，然后删除根节点，如此反复直到堆为空。上面提到了删除操作，每次删除之后都是要调整堆让堆的性质不变，即根节点必为最大值或最小值，明白了吗？

   代码如下：

   ```java
      /*根据树的性质建堆，树节点前一半一定是分支节点，即有孩子的，所以我们从这里开始调整出初始堆*/  
        public static void adjust(List<Integer> heap){
           for (int i = heap.size() / 2; i > 0; i--)  
               adjust(heap,i, heap.size()-1);  
             
           System.out.println("=================================================");
           System.out.println("调整后的初始堆：");
             print(heap);
         }
       /** 
        * 调整堆，使其满足堆得定义 
        * @param i 
        * @param n 
        */  
       public static void adjust(List<Integer> heap,int i, int n) {  
          
           int child;  
           for (; i <= n / 2; ) {  
               child = i * 2;  
               if(child+1<=n&&heap.get(child)<heap.get(child+1))  
                   child+=1;/*使child指向值较大的孩子*/  
               if(heap.get(i)< heap.get(child)){  
                   swap(heap,i, child);  
                   /*交换后，以child为根的子树不一定满足堆定义，所以从child处开始调整*/  
                   i = child;  
                  
               }  else break;
           }  
       }  
   ```

##### 最大堆的插入

​	由于需要维持完全二叉树的形态，需要先将要插入的结点x放在最底层的最右边，插入后满足完全二叉树的特点。 然后把 x 依次向上调整到合适位置满足堆的性质，例如下图中插入80，先将80放在最后，然后两次上浮到合适位置。

​	时间：O(logn)。 流程图如下：

![](./assets/%E6%9C%80%E5%A4%A7%E5%A0%86%E6%8F%92%E5%85%A5%E6%96%B0%E5%85%83%E7%B4%A0.png)

​	代码实现如下：

```java
 		//向最大堆中插入元素, heap:存放堆元素的数组
    public static void insert(List<Integer> heap, int value) { 
       //在数组的尾部添加
        if(heap.size()==0)
          heap.add(0);//数组下标为0的位置不放元素
        heap.add(value); 
        //开始上升操作 
       // heapUp2(heap, heap.size() - 1); 
        heapUp(heap, heap.size() - 1); 
 
    } 
 
    //上升，让插入的数和父节点的数值比较，当大于父节点的时候就和父节点的值相交换 
    public static void heapUp(List<Integer> heap, int index) { 
 
        //注意由于数值是从下标为1开始，当index = 1的时候，已经是根节点了 
        if (index > 1) { 
            //求出父亲的节点 
            int parent = index / 2; 
 
            //获取相应位置的数值 
            int parentValue = (Integer) heap.get(parent); 
            int indexValue = (Integer) heap.get(index); 
            //如果父亲节点比index的数值小，就交换二者的数值 
            if (parentValue < indexValue) { 
                //交换数值 
                swap(heap, parent, index); 
                //递归调用 
                heapUp(heap, parent); 
            } 
 
        } 
    } 
```

##### 最大堆的删除

​	操作原理是：当删除节点的数值时，原来的位置就会出现一个孔,填充这个孔的方法就是， 把最后的叶子的值赋给该孔并下调到合适位置，最后把该叶子删除。 

​	如图中要删除72,先用堆中最后一个元素来35替换72,再将35下沉到合适位置,最后将叶子节点删除。

![](./assets/%E6%9C%80%E5%A4%A7%E5%A0%86%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.png)

​	代码实现如下：

```java
	 /**
     * 删除堆中位置是index处的节点
     * 操作原理是：当删除节点的数值时，原来的位置就会出现一个孔
     * 填充这个孔的方法就是，把最后的叶子的值赋给该孔，最后把该叶子删除
     * @param heap 
     */ 
    public static void delete(List<Integer> heap,int index) { 
        //把最后的一个叶子的数值赋值给index位置 
        heap.set(index, heap.get(heap.size() - 1)); 
        //下沉操作 
        //heapDown2(heap, index); 
        heapDown(heap, index); 
        //把最后一个位置的数字删除 
        heap.remove(heap.size() - 1); 
    } 
    /**
     * 递归实现
     * 删除堆中一个数据的时候，根据堆的性质，应该把相应的位置下移，才能保持住堆性质不变
     * @param heap 保持堆元素的数组
     * @param index 被删除的那个节点的位置
     */ 
    public static void heapDown(List<Integer> heap, int index) { 
        //因为第一个位置存储的是空值，不在考虑之内 
        int n = heap.size() - 2; 
 
        //记录最大的那个儿子节点的位置 
        int child = -1; 
 
        //2*index>n说明该节点没有左右儿子节点了，那么就返回 
        if (2 * index > n) { 
            return; 
        } //如果左右儿子都存在 
        else if (2 * index < n) { 
 
            //定义左儿子节点 
            child = 2 * index; 
            //如果左儿子小于右儿子的数值，取右儿子的下标 
            if ((Integer) heap.get(child) < (Integer) heap.get(child + 1)) { 
                child++; 
            } 
 
        }//如果只有一个儿子（左儿子节点） 
        else if (2 * index == n) { 
            child = 2 * index; 
        } 
 
        if ((Integer) heap.get(child) > (Integer) heap.get(index)) { 
            //交换堆中的child，和index位置的值 
            swap(heap, child, index); 
 
            //完成交换后递归调用，继续下降 
            heapDown(heap, child); 
        } 
    } 
```

##### 最大堆排序

```java
		//对一个最大堆heap排序
    public static void heapSort(List<Integer> heap) {  
       
        for (int i = heap.size()-1; i > 0; i--) {  
         /*把根节点跟最后一个元素交换位置，调整剩下的n-1个节点，即可排好序*/  
            swap(heap,1, i);  
            adjust(heap,1, i - 1);  
        }  
    }
```

补充：swap的代码如下：

```java
    //把堆中的a,b位置的值互换   
    public static void swap(List<Integer> heap, int a, int b) {   
        //临时存储child位置的值   
        int temp = (Integer) heap.get(a);   
   
        //把index的值赋给child的位置   
        heap.set(a, heap.get(b));   
   
        //把原来的child位置的数值赋值给index位置   
        heap.set(b, temp);   
    }   
```

# 

### 二叉排序树 和 平衡二叉树

##### 完全二叉树

​	若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。如下图所示：

![](assets/完全二叉树.png)

```
二叉排序树和二叉平衡树二叉搜索树 都是一种数据结构
平衡二叉树的常用算法有红黑树，AVL树等我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。
最小二叉平衡树的节点的公式如下：
F(n)=F(n-1)+F(n-2)+1
真的和斐波那契数列差不多！
但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
AVL是第一种被发明的自平衡二叉查找树
```

##### 平衡二叉搜索树

​	平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![](assets/平衡二叉搜索树.png)

### B-树

```
B树(B-Tree) 也是一种用于查找的平衡树，但是不是一种二叉树，多叉的。
这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，
B-树为系统最优化大块数据的读和写操作。
B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。

在B-树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。

B-树作为一种多路搜索树（并不是二叉的）：

　　1) 定义任意非叶子结点最多只有M个儿子；且M>2；
　　2) 根结点的儿子数为[2, M]；
　　3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；
　　4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
　　5) 非叶子结点的关键字个数=指向儿子的指针个数-1；
　　6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
　　7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
　　8) 所有叶子结点位于同一层；
　　
　　首先 定义任意非叶子结点最多只有M个儿子；且M>2；根结点的儿子数为[2,M]；
　　非根结点的非叶子结点的儿子数为[M/2,M]
　　对于叶子结点，每个结点存放至少M/2-1 和至多M个关键字
    如下图为一个M=3的B树示例：
    
    
    
因此B-树的搜索，有可能在非叶子结点结束，而B+树则不是如此
```

![btreebuild](/Users/Haoyu/Desktop/btreebuild.gif)

### B+树

```
B+树是B树的变体，也是一种多路搜索树：

　　1) 其定义基本与B-树相同，除了：
　　2) 非叶子结点的子树指针与关键字个数相同；
　　3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
　　4) 为所有叶子结点增加一个链指针；
　　5) 所有关键字都在叶子结点出现；

　　下图为M=3的B+树的示意图：
　　B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

　　B+的性质：
　　1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
　　2.不可能在非叶子结点命中；//搜索最后结果都是在叶子结点，所以，无论搜没搜索中走的都是根到叶子结点的一个路径长度
　　3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

　　4.更适合文件索引系统。
```



#### B- B+区别小结

```
B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；

       B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；

       所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

       B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

       B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；
```

### 字典树 Trie Tree

- 字典树或者说前缀树用到的数据结构，ListNode []children,对于每一个结点都有这个。是层层嵌套的数组，因为字母只有26个，和之前用数组对字符串出现的单词进行计数的思想一样，这样用数组来存，树的深度为字符长度，并且单个字母只用一次，节省空间开销。共同前缀的单词，但是做搜索可以，做遍历就有点难

### [红黑树](https://www.cnblogs.com/CarpenterLee/p/5503882.html)

##### 红黑树与2-3树

​	红黑树与2-3树十分类似。红黑树中**红色节点其实就是2-3树中的3-节点最左侧的元素。该节点表示其应该与其父亲节点合在一起，等价于2-3树中的一个3-节点**。正因为该原因，在红黑树中添加元素时，新元素永远是红色节点（与2-3树中添加新元素原理对应：向2-3树中添加一个元素，如果新元素添加进2-节点，那就直接形成一个3-节点，如果新元素添加进3-节点，则暂时形成一个4-节点，再对该节点进行变形处理）。

##### 红黑树的五大性质

1. 每个节点不是红色就是黑色；
2. 根节点是黑色的；
3. 每一个叶子节点（最后的空节点）是黑色的；
4. 如果一个节点是红色，那么他的孩子节点都是黑色的；
5. 从任意一个节点到叶子节点，所经过的黑色节点是一样的；

##### 左旋

​	前文说到当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：**左旋（Rotate Left），右旋（RotateRight）**。

​	**左旋即将旋转中心节点的左孩子节点给自己的父节点，当做右孩子节点，父节点成为自己新的左孩子节点。**

![](assets/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B.png)

​	源代码实现：

```java
public class RBTree<T extends Comparable<T>> {

    private RBTNode<T> mRoot;    // 根结点

    private static final boolean RED   = false;
    private static final boolean BLACK = true;

    public class RBTNode<T extends Comparable<T>> {
        boolean color;        // 颜色
        T key;                // 关键字(键值)
        RBTNode<T> left;    // 左孩子
        RBTNode<T> right;    // 右孩子
        RBTNode<T> parent;    // 父结点

        public RBTNode(T key, boolean color, RBTNode<T> parent, RBTNode<T> left, RBTNode<T> right) {
            this.key = key;
            this.color = color;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

    }

    ...
}
结点定义

//Rotate Left
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> r = p.right;
        p.right = r.left;
        if (r.left != null)
            r.left.parent = p;
        r.parent = p.parent;
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p;
        p.parent = r;
    }
}

```

##### 右旋

​	**右旋即将旋转中心节点的右孩子节点给自己的父节点，当做左孩子节点，父节点成为自己新的右孩子节点。**

![](assets/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8B.png)

```java
//Rotate Right
private void rotateRight(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> l = p.left;
        p.left = l.right;
        if (l.right != null) l.right.parent = p;
        l.parent = p.parent;
        if (p.parent == null)
            root = l;
        else if (p.parent.right == p)
            p.parent.right = l;
        else p.parent.left = l;
        l.right = p;
        p.parent = l;
    }
}
```

##### 创建实例

创建的总体流程图如下：

![](assets/TreeMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B2.2.png)

1. put(10, "10")

   首先是put(10, "10")，由于此时TreeMap中没有任何节点，因此10为根且根节点为黑色节点，put(10, "10")之后的数据结构为：

   ![](assets/TreeMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B1.png)

2. put(85, "85")

   ​	接着是put(85, "85")，这一步也不难，85比10大，因此在10的右节点上，默认新插入节点为红色节点。

   ​	这是由于红黑树要求从根节点到叶子所有叶子节点上经过的黑色节点个数是相同的，因此如果插入的节点着色为黑色，那必然有可能导致某条路径上的黑色节点数量大于其他路径上的黑色节点数量，**因此默认插入的节点必须是红色的**。

   

   ![](assets/TreeMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B2.png)

3. put(15, "15")

   ​	这次添加的是put(15, "15")，15比10大且比85小，因此15最终应当是85的左子节点，默认插入的是红色节点，因此首先将15作为红色节点插入85的左子节点后的结构应是下图左一：

   ![](assets/TreeMap%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B3.3.png)

   ​	在这里先补充一下左子树内侧插入、左子树外侧插入以及右子树内侧插入、右子树外侧插入的概念：

   - 左子树内侧插入：新插入的节点为左子树的右孩子节点(相对于root，新插入节点在内侧)；
   - 左子树外侧插入：新插入的节点为左子树的左孩子节点(相对于root，新插入的节点在外侧)；
   - 右子树内侧插入：新插入的节点为右子树的左孩子节点(相对于root，新插入节点在内侧)；
   - 右子树外侧插入：新插入的节点为右子树的右孩子节点(相对于root，新插入的节点在外侧)。

   ​	回到上面的流程，显然这里违反了红黑树的性质即连续出现了两个红色节点，**且不存在叔父节点为红色的情况**，因此此时必须进行旋转。可以看到这是**右子树内侧插入**，需要进行两次旋转操作（**所有内侧插入都需要进行两次旋转、外侧插入都需要经过一次旋转**）：

   1. 以新插入节点为旋转中心进行一次右旋操作(将旋转中心的右孩子节点给自己的父亲节点，当做左孩子节点，父节点成为旋转中心节点的新的右孩子节点。)
   2. 新插入节点的父节点着色为黑色，新插入节点的祖父节点着色为红色
   3. 再以新插入节点为中心进行一次左旋操作(将旋转中心节点的左孩子节点给自己的父亲节点，当做右孩子节点，父亲节点成为旋转中心节点的新的左孩子节点)

4. put(70, "70")

   ​	put(70, "70")就很简单了，70是85的左子节点，**由于70的父节点以及叔父节点都是红色节点，因此直接将70的父节点85、将70的叔父节点10着色为黑色即可，70这个节点着色为红色**，即满足红黑树的特性，插入70之后的结构图为：

   ![](assets/TreeMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B4.png)

5. put(20, "20")

   可以看出此处为**左子树外侧插入**，父节点为红色，且不存在叔父节点也为红色的情况，需要按照子树外侧插入的规则来进行旋转，此处即为以新插入节点的父节点为旋转中心，进行右旋操作，具体操作流程为：**以新插入节点的父节点为旋转中心，将旋转中心的右孩子节点给旋转中心的父节点，当做左孩子节点，父节点成为旋转中心节点的新的右孩子节点：**

   ![](assets/TreeMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B5.1.png)

   

6. put(60, "60")

   这里出现了连续两个红色节点，且新插入节点的叔父节点也为红色，所以只需要进行一次颜色变换再重复判断是否依然存在颜色错误问题即可，调整后如下：

   ![](assets/TreeMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B6.png)

7. put(30, "30")

   put(30, "30")，节点30应当为节点60的左子节点，因此插入节点30之后是下图左一：

   ![](assets/TreeMap%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B7.1.png)

   此时违背了红黑树不能有两个连续红色节点的性质，且新插入节点不存在叔父节点也为红色，判断新插入节点为右子树内侧插入，需要经历右旋->颜色变换->左旋操作，具体操作如下：

   - 右旋：以新插入节点（值为30）为中心，将自己的右孩子节点（为空）给自己的父亲节点（值为60），当做左孩子节点，父亲节点成为了自己的新的右孩子节点；
   - 颜色变换：新插入节点（值为30）变为黑色，父节点（此处为调整后的父节点，即值为20的节点）和右孩子节点（值为60）变为红色；
   - 左旋：以新插入节点（值为30）为中心，进行一次左旋操作，将自己的左孩子节点（为空）给自己的父亲节点（值为20）当做右孩子节点，父亲节点（值为20）成了自己的新的左孩子节点。

   调整后的结构如上面右图所示。

8. put(50, "50")

   ​	put(50, "50")，节点50应当为节点60的左子节点，因此插入节点30之后，且新插入节点的父节点和叔父节点都为红色节点，因此在插入时直接进行颜色变换，父节点和叔父节点变为黑色，祖父节点变为红色，如下第一张图所示：

   ![](assets/TreeMap%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B8.png)![](assets/TreeMap%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B8.2.png)![](assets/TreeMap%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B8.3.png)![](assets/TreeMap%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B8.4.png)

   ​	由图一可以观察到，树中存在连续红色节点的情况，需要进行调整，此处相当于在70节点处新插入了一个左子树，为右子树内侧插入，需要经过 右旋->颜色变换->左旋操作，具体操作流程如下：

   - 右旋：以新插入节点（值为30）为中心，将自己的右子树给自己的父节点(值为70)，当做左子树，父节点成为自己新的右孩子节点。调整后如上图二所示；
   - 颜色变换：新插入节点(值为30)变为黑色，父节点(值为15)和右孩子节点（值为70）变为红色。调整后如图三所示（此时先不用管根节点成了红色，先把右子树内侧插入的流程走完，这样就会自动将根节点调整过来）；
   - 左旋：以新插入节点（值为30）为中心，将自己的左子树（左子树根节点值为20）给自己的父节点（值为15），当做父节点的右子树，父节点成了自己的新的左孩子节点，调整后的结构如图四所示。

##### 创建流程核心总结

**如以上流程所示，红黑树的完整建立流程就已经搞定。核心需要注意的地方有如下几个：**

1. **按照遍历规则（二分查找法）找到新插入节点的位置，且新插入的节点必定为红色，如果是根节点，则直接调整为黑色；**
2. **如果新插入节点的父节点为红色，则代表发生冲突，需要调整，调整规则如下：**
   - **若父节点与叔父节点同时为红色，则直接将父节点与叔父节点设置成黑色，将祖父节点设置成红色。**
   - **若只有父节点为红色，则需要判断当前节点插入为内侧插入还是外侧插入，如果是内侧插入，则必须进行以插入节点为中心的 右旋->颜色变换（新插入节点变成黑色，右旋操作后新插入节点的父节点变成红色）->左旋 操作；如果是外侧插入，则只需要进行以插入节点的父节点为中心的右旋操作；**
3. **解决新插入节点的颜色冲突后，重新检查树中是否因为刚刚的颜色调整产生了新的颜色冲突，若有冲突，则继续执行步骤2(将发生冲突的地方视为新插入了节点)**

##### get()

​	即二分查找法，此处不再赘述。

![](assets/%E7%BA%A2%E9%BB%91%E6%A0%91get.png)

##### put()

​	与创建流程类似，此处不再赘述，可以通过以下的put流程检测自己是否真的理解之前的创建操作。

![](assets/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%B0%83%E6%95%B4%E8%BF%87%E7%A8%8B.png)

##### [remove()](https://www.cnblogs.com/CarpenterLee/p/5525688.html)

​	由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，即从根节点到叶子节点所经过的黑色节点数目不一致，因此有可能要进行调整。

### 二叉树的序列化与反序列化

```java
public class Codec {

    public String serialize(TreeNode root) {
        if (root == null) {
            return null;
        }
        // 利用二叉树的层次遍历方式进行序列化
        StringBuilder res = new StringBuilder();
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.remove();
            if (node != null) {
                res.append(node.val).append(",");
                queue.add(node.left);
                queue.add(node.right);
            } else {
                res.append("null,");
            }
        }
        return res.toString();
    }

    public TreeNode deserialize(String data) {
        if (data == null || data.length() == 0) {
            return null;
        }
        String[] dataArr = data.split(",");
        // 层次遍历逆向还原二叉树
        int index = 0;
        TreeNode root = toNode(dataArr[index]);
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (index < dataArr.length - 2 && !queue.isEmpty()) {
            TreeNode cur = queue.remove();
            // 添加左子节点
            TreeNode leftNode = toNode(dataArr[++index]);
            cur.left = leftNode;
            // 队列中的节点用于为其赋值孩子节点，若该节点本身为 null，
            // 没有孩子节点，便不再添加到队列中，下同理
            if (leftNode != null) {
                queue.add(leftNode);
            }
            // 添加右子节点
            TreeNode rightNode = toNode(dataArr[++index]);
            cur.right = rightNode;
            if (rightNode != null) {
                queue.add(rightNode);
            }
        }
        return root;
    }

    private TreeNode toNode(String val) {
        if (!"null".equals(val)) {
            return new TreeNode(Integer.parseInt(val));
        } else {
            return null;
        }
    }
}
```



# 哈希表

### 什么是哈希算法，哈希思想

```
对象的存储位置（或者索引）与对象的关键属性之间形成一个特定的对应关系f(k)
k关键属性 f(k) 地址空间的一个值，或者再构成一层索引，f()就是哈希函数
```

hash算法，本身可以用作信息安全领域和数据结构领域，一个用作加密，比如MD5，你下载的任何副本的数字指纹只要和官方给出的数据指纹一致，就可以知道这是未经篡改的。例如著名的MD5

### 选定哈希函数

```
选定哈希函数通常要考虑
1.计算时间
2.关键字的长度
3.Hash表的大小，//尽量减少哈希冲突出现的几率
4.关键字的分布情况，//聚集的话，很容易出现hash冲突
5.记录的查找频率
```

### 常用哈希函数

```
1.直接寻址法 关键字和地址一一对应 这样空间复杂度太高
2.数字分析法：找出关键字的规律，尽可能用差异数据去构造Hash地址 比如在HashMap中就是（hashcode&num.length-1）
3.平方取中法：先求平均值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。
4.折叠法：将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。
5.随机数法
6.除留取余法 取关键字被某个不大于Hash表 长m 的数p 除后所得的余数为Hash地址 。
特点：这是最简单也是最常用的Hash函数构造方法。可以直接取模，也可以在平法法、折叠法之后再取模。
值得注意的是，在使用除留取余法 时，对p 的选择很重要，如果p 选的不好会容易产生同义词 。由经验得知：p 最好选择不大于表长m的一个质数 、或者不包含小于20的质因数的合数。 这个的确是最常用的哈希函数构造法。
```

### 哈希冲突的解决

其实哈希地址就像是一个个的桶，难免有两个key的哈希地址一样放在同一个桶里

```
第一个方法：拉链法或者说链地址法
对每个hash地址对应的数组位置接一条链表，这个时候数组大小也会很关键，数组太小，哈希地址太少，链表就会很长，而链表查找大家都知道是O(n)

第二个方法：再哈希法 用不同的哈希函数再算一遍
均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生，这种方法不易产生聚集 ，但增加了计算时间；

第三个方法：公共溢出区法
可以建立一个公共溢出区，用来存放有冲突的Key 。比如设立另一个哈希表，专门用来存放出现冲突的同义词。如果在数组相应位置用equal没有找到，就到溢出区去找。

还有另一种常用的解决方法：线性探测法
线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，
开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：
1.命中，该位置的键和被查找的键相同
2.未命中，键为空
3.继续查找，该位置和键被查找的键不同。
但是线性探测法存在问题是，虽然简单，但是会导致同类哈希聚集，在存入的时候存在冲突，在查找的时候冲突依然存在。
```

### 哈希查找与分析

```
我们可以看到，哈希表存储和查找数据的时候分为两步，第一步为将键通过哈希函数映射为数组中的索引， 这个过程可以认为是只需要常数时间的。第二步是，如果出现哈希值冲突，如何解决，前面介绍了拉链法和线性探测法下面就这两种方法进行讨论：

对于拉链法，查找的效率在于链表的长度，一般的我们应该保证长度在M/8~M/2之间，如果链表的长度大于M/2，我们可以扩充链表长度。如果长度在0~M/8时，我们可以缩小链表。

对于线性探测法，也是如此，但是动态调整数组的大小需要对所有的值从新进行重新散列并插入新的表中。

不管是拉链法还是散列法，这种动态调整链表或者数组的大小以提高查询效率的同时，还应该考虑动态改变链表或者数组大小的成本。散列表长度加倍的插入需要进行大量的探测， 这种均摊成本在很多时候需要考虑。
```

##### 补充：hash碰撞攻击 

hash表退化为单链表从而消耗cpu资源 造成hash攻击