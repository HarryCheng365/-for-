- 给定入栈序列，判断给出的出栈序列可不可能||求出所有的出栈序列||给定树的结点，求有多少种树？

#### 卡特兰数

```
对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。

在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。

不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。

反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。

因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。

显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)。

还让我们用C++写了当时
```

## 数据结构：

```
基本策略：
1.Leetcode刷题，根据Leetcode给出的题库
2.一天 计网||数据库||多线程编程||Spring相关 换着来 一天一个专题
3.博客也不要拉下，阿里大神的算法博客，多整理笔记，精神高度集中其他课就不看了
4.最后开始看面试70题，面试100题之类的查漏补缺

```



## 编程常用容器类：

- Vector Vector就是队列 可以这么说

  ```Java
  Vector vq= new Vector();
  vq.addElement(months[i]+" ");
  vq.removeElement(vq.firstElement());//先进先出
  ```

  

- List集合去重

  https://www.cnblogs.com/cainiao-Shun666/p/7911142.html

- HashMap如何遍历

  https://blog.csdn.net/gary0917/article/details/79783713

- Java中 List Integer 和int int[]的转换

  <https://blog.csdn.net/zx000003/article/details/82691578>

- 栈Stack

  ```
  Stack底层 用数组，可变数组，链表都可以实现
  ```

## 字符串subString()

- substring(int beginIndex)

  是截取扔掉前beginIndex个 留下beginIndex后的字符

- substring(int beginIndex,int endIndex)

  是截取beginIndex到endIndex中间这么多个

## 数组与链表：单/双向链表，跳舞链 //开始刷leetcode

- 单向链表的增删改查
- 









## 栈与队列

## 树与图：最近公共祖先、并查集

- 二叉排序树 和 平衡二叉树

  ```
  二叉排序树和二叉平衡树二叉搜索树 都是一种数据结构
  平衡二叉树的常用算法有红黑树，AVL树等我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。
  最小二叉平衡树的节点的公式如下：
  F(n)=F(n-1)+F(n-2)+1
  真的和斐波那契数列差不多！
  但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
  AVL是第一种被发明的自平衡二叉查找树
  ```

  

- B树

  ```
  B树(B-Tree) 也是一种用于查找的平衡树，但是不是一种二叉树，多叉的。
  这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
  是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
  B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，
  B-树为系统最优化大块数据的读和写操作。
  B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。
  
  在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。
  
  B树作为一种多路搜索树（并不是二叉的）：
  
  　　1) 定义任意非叶子结点最多只有M个儿子；且M>2；
  　　2) 根结点的儿子数为[2, M]；
  　　3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；
  　　4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
  　　5) 非叶子结点的关键字个数=指向儿子的指针个数-1；
  　　6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
  　　7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
  　　8) 所有叶子结点位于同一层；
  　　
  　　首先 定义任意非叶子结点最多只有M个儿子；且M>2；根结点的儿子数为[2,M]；
  　　非根结点的非叶子结点的儿子数为[M/2,M]
  　　对于叶子结点，每个结点存放至少M/2-1 和至多M个关键字
      如下图为一个M=3的B树示例：
  ```

  ![btreebuild](/Users/Haoyu/Desktop/btreebuild.gif)

- B+树

  ```
  B+树是B树的变体，也是一种多路搜索树：
  
  　　1) 其定义基本与B-树相同，除了：
  
  　　2) 非叶子结点的子树指针与关键字个数相同；
  
  　　3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
  
  　　4) 为所有叶子结点增加一个链指针；
  
  　　5) 所有关键字都在叶子结点出现；
  
  　　下图为M=3的B+树的示意图：
  　　B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
  
  　　B+的性质：
  　　1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
  　　2.不可能在非叶子结点命中；
  
  　　3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
  
  　　4.更适合文件索引系统。
  ```

  

  

- 最近公共祖先

  

## 哈希表

- 什么是哈希算法，哈希思想

  ```
  对象的存储位置（或者索引）与对象的关键属性之间形成一个特定的对应关系f(k)
  k关键属性 f(k) 地址空间的一个值，或者再构成一层索引，f()就是哈希函数
  ```

- hash算法，本身可以用作信息安全领域和数据结构领域，一个用作加密，比如MD5，你下载的任何副本的数字指纹只要和官方给出的数据指纹一致，就可以知道这是未经篡改的。例如著名的MD5

- 选定哈希函数

  ```
  选定哈希函数通常要考虑
  1.计算时间
  2.关键字的长度
  3.Hash表的大小，//尽量减少哈希冲突出现的几率
  4.关键字的分布情况，//聚集的话，很容易出现hash冲突
  5.记录的查找频率
  ```

- 常用哈希函数

  ```
  1.直接寻址法 关键字和地址一一对应 这样空间复杂度太高
  2.数字分析法：找出关键字的规律，尽可能用差异数据去构造Hash地址
  3.平方取中法：先求平均值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。
  4.折叠法：将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。
  5.随机数法
  6.除留取余法 取关键字被某个不大于Hash表 长m 的数p 除后所得的余数为Hash地址 。
  特点：这是最简单也是最常用的Hash函数构造方法。可以直接取模，也可以在平法法、折叠法之后再取模。
  值得注意的是，在使用除留取余法 时，对p 的选择很重要，如果p 选的不好会容易产生同义词 。由经验得知：p 最好选择不大于表长m的一个质数 、或者不包含小于20的质因数的合数。 这个的确是最常用的哈希函数构造法。
  ```

- 哈希冲突的解决，其实哈希地址就像是一个个的桶，难免有两个key的哈希地址一样放在同一个桶里

  ```
  第一个方法：拉链法或者说链地址法
  对每个hash地址对应的数组位置接一条链表，这个时候数组大小也会很关键，数组太小，哈希地址太少，链表就会很长，而链表查找大家都知道是O(n)
  
  第二个方法：再哈希法 用不同的哈希函数再算一遍
  均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生，这种方法不易产生聚集 ，但增加了计算时间；
  
  第三个方法：公共溢出区法
  可以建立一个公共溢出区，用来存放有冲突的Key 。比如设立另一个哈希表，专门用来存放出现冲突的同义词。如果在数组相应位置用equal没有找到，就到溢出区去找。
  
  还有另一种常用的解决方法：线性探测法
  线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，
  开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：
  1.命中，该位置的键和被查找的键相同
  2.未命中，键为空
  3.继续查找，该位置和键被查找的键不同。
  但是线性探测法存在问题是，虽然简单，但是会导致同类哈希聚集，在存入的时候存在冲突，在查找的时候冲突依然存在。
  ```

- 查找与分析

  ```
  我们可以看到，哈希表存储和查找数据的时候分为两步，第一步为将键通过哈希函数映射为数组中的索引， 这个过程可以认为是只需要常数时间的。第二步是，如果出现哈希值冲突，如何解决，前面介绍了拉链法和线性探测法下面就这两种方法进行讨论：
  
  对于拉链法，查找的效率在于链表的长度，一般的我们应该保证长度在M/8~M/2之间，如果链表的长度大于M/2，我们可以扩充链表长度。如果长度在0~M/8时，我们可以缩小链表。
  
  对于线性探测法，也是如此，但是动态调整数组的大小需要对所有的值从新进行重新散列并插入新的表中。
  
  不管是拉链法还是散列法，这种动态调整链表或者数组的大小以提高查询效率的同时，还应该考虑动态改变链表或者数组大小的成本。散列表长度加倍的插入需要进行大量的探测， 这种均摊成本在很多时候需要考虑。
  ```

  

- 拓展：hash碰撞攻击 hash表退化为单链表从而消耗cpu资源 造成hash攻击