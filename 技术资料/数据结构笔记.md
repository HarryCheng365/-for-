- 给定入栈序列，判断给出的出栈序列可不可能||求出所有的出栈序列||给定树的结点，求有多少种树？

#### 卡特兰数

```
对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。

在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。

不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。

反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。

因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。

显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)。

还让我们用C++写了当时
```

## 数据结构：

```
基本策略：
1.Leetcode刷题，根据Leetcode给出的题库
2.一天 计网||数据库||多线程编程||Spring相关 换着来 一天一个专题
3.博客也不要拉下，阿里大神的算法博客，多整理笔记，精神高度集中其他课就不看了
4.最后开始看面试70题，面试100题之类的查漏补缺

```





## 数组与链表：单/双向链表，跳舞链 //开始刷leetcode

- 单向链表的增删改查









## 栈与队列

## 树与图：最近公共祖先、并查集

- 二叉排序树 和 平衡二叉树

  ```
  二叉排序树和二叉平衡树二叉搜索树 都是一种数据结构
  平衡二叉树的常用算法有红黑树，AVL树等我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。
  最小二叉平衡树的节点的公式如下：
  F(n)=F(n-1)+F(n-2)+1
  真的和斐波那契数列差不多！
  但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
  AVL是第一种被发明的自平衡二叉查找树
  ```

  

- B树

  ```
  B树(B-Tree) 也是一种用于查找的平衡树，但是不是一种二叉树，多叉的。
  这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
  是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
  B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，
  B-树为系统最优化大块数据的读和写操作。
  B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。
  
  在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。
  
  B树作为一种多路搜索树（并不是二叉的）：
  
  　　1) 定义任意非叶子结点最多只有M个儿子；且M>2；
  　　2) 根结点的儿子数为[2, M]；
  　　3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；
  　　4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
  　　5) 非叶子结点的关键字个数=指向儿子的指针个数-1；
  　　6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
  　　7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
  　　8) 所有叶子结点位于同一层；
  　　
  　　首先 定义任意非叶子结点最多只有M个儿子；且M>2；根结点的儿子数为[2,M]；
  　　非根结点的非叶子结点的儿子数为[M/2,M]
  　　对于叶子结点，每个结点存放至少M/2-1 和至多M个关键字
      如下图为一个M=3的B树示例：
  ```

  ![btreebuild](/Users/Haoyu/Desktop/btreebuild.gif)

- B+树

  ```
  B+树是B树的变体，也是一种多路搜索树：
  
  　　1) 其定义基本与B-树相同，除了：
  
  　　2) 非叶子结点的子树指针与关键字个数相同；
  
  　　3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
  
  　　4) 为所有叶子结点增加一个链指针；
  
  　　5) 所有关键字都在叶子结点出现；
  
  　　下图为M=3的B+树的示意图：
  　　B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
  
  　　B+的性质：
  　　1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
  　　2.不可能在非叶子结点命中；
  
  　　3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
  
  　　4.更适合文件索引系统。
  ```

  

  

- 最近公共祖先

  

## 哈希表

- 什么是哈希算法，哈希思想

  ```
  对象的存储位置（或者索引）与对象的关键属性之间形成一个特定的对应关系f(k)
  k关键属性 f(k) 地址空间的一个值，或者再构成一层索引，f()就是哈希函数
  ```

- hash算法，本身可以用作信息安全领域和数据结构领域，一个用作加密，比如MD5，你下载的任何副本的数字指纹只要和官方给出的数据指纹一致，就可以知道这是未经篡改的。例如著名的MD5

- 



## 算法：



## 排序算法

- 常用排序算法 记忆汇总

![img](http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg)



```
比较类排序规则：
交换排序：冒泡排序，快速排序
插入排序：简单插入排序，shell（希尔）排序
选择排序：简单选择排序，堆排序
归并排序：二路归并排序，多路归并排序

非比较类排序，可以突破nlog2n的平均限制，线性时间非比较类排序 
（这个n是来自，对于每一个元素都要走一遍，对单个元素，反而像是查找）
基数排序，桶排序，计数排序
```

- 交换排序

  ```
  冒泡排序： 时间复杂度 最好O(n) 最坏O(n^2) 平均O(nlog2n) 空间复杂度 O(1)
  for(int i=0;i<nums.length;i++){
      for(int j=0;j<nums.length-1-i;j++){
          if(nums[j]>nums[j+1]){
              int temp=nums[j+1];
              nums[j+1]=nums[j];
              nums[j]=temp;
          }
      }   
  }
  // 排序完后，如果是从小到大排序，一定可以找到最大值
  ```

- 选择排序

  ```
  选择排序(Selection-sort)是一种简单直观的排序算法。
  它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
  选择排序： 时间复杂度 最好O(n^2) 最坏 O(n^2) 平均O(n^2) 空间复杂度 O(1)
  for(int i=0;i<nums.length;i++){
      int minIndex=i;
      int min=nums[i];
      for(int j=i+1;j<nums.length;j++){
          if(nums[j]<min){
              minIndex=j;
              min=nums[j];
          }
      }
      int temp=nums[i];
      nums[i]=min;
      nums[minIndex]=temp;  
  }
  //数据规模越小越好 一定能找到最大最小
  ```

- 插入排序

  ```
  插入排序: 最好O(n) 最坏 O(n^2) 平均O(n^2) 空间复杂度O(1)
  for(int i=1;i<nums.length;i++){
  	int preindex=i-1;
  	int temp=nums[i];
     while(preindex>=0&&nums[preindex]>temp){
         nums[preindex+1]=nums[preindex];
         preindex--;
     }
     nums[preindex+1]=temp;
  }
  //与前一个比较，如果发现前一个比当今小，就不会进行插入，所以 最好为O(n)
  ```

- 插入排序（shell排序）

  ```java
  希尔排序：关键在设置增量 最好 O(n) 最坏O(n^2) 平均O(n^1.3)
  if(arrays == null || arrays.length <= 1){
              return;
          }
          //增量
          int incrementNum = arrays.length/2;
          while(incrementNum >=1){
              for(int i=0;i<arrays.length;i++){
                  //进行插入排序
                  for(int j=i;j<arrays.length-incrementNum;j=j+incrementNum){
                      if(arrays[j]>arrays[j+incrementNum]){
                          int temple = arrays[j];
                          arrays[j] = arrays[j+incrementNum];
                          arrays[j+incrementNum] = temple;
                      }
                  }
              }
              //设置新的增量
              incrementNum = incrementNum/2;
          }
      }
  ```

- 归并排序(分治法的典型应用)

  ```
  
  ```

  

## 搜索算法 

- 回溯、递归、剪枝搜索算法 其实就是查找算法

- 查找算法的分类（七种）

  ```
  插值查找：二分查找，插值查找，斐波那契查找
  其他：哈希查找，树表查找
  查找算法分类：
  1.静态查找和动态查找（动态静态都是针对查找表而言的，即在查找过程中是否需要对表进行改动）
  2.无序查找和有序查找（即被查找数列是否必须为有序数列）
  其他关键字：平均查找长度 ASL
  ```

- 顺序查找

  ```
  顺序查找适合于存储结构为顺序存储结构或链接存储结构的线性表
  顺序查找适合于存储结构为顺序存储或链式存储的线性表
  时间复杂度O(n) 空间复杂度O(0)
  就一个个的查找和比较
  想要快，就要空间换时间，或者找到个折中的办法
  ```

- 二分查找

  ```
  二分查找，元素必须是有序的，如果是无序的则要先进行排序操作。
  也被称为折半查找
  其实，和堆排序 和  排序的原理一致
  就是先和关键字比较，等于就m 小了就m-1 大了就m+1 然后重新计算中点
  时间复杂度为(log2n)
  折半查找的前提条件是需要有序表顺序排序，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或者删除的数据集来说，维护有序的排序会带来不小的工作量，所以动态表并不是太推荐使用二分查找。
  
  非递归版本
  public int BinarySearch(int nums[],int value){
      int high=nums.length-1;
      int low=0;
      int mid=(high+low)/2或者 low+(high-low)/2;
      Arrays.sort(nums);
      while(low<=high){
      mid=(high+low)/2或者 low+(high-low)/2;
      if(nums[mid]==value)
      return mid;
      if(nums[mid]>value)
      low=mid+1;
      if(nums[mid]<value)
      high=mid-1;    
      }
      return -1;    
  }
  
  递归版本
  public int BinarySearch(int nums[],int value,int low ,int high){
  	int mid=(high+low)/2或者 low+(high-low)/2;
  	if(nums[mid] ==value)
  		return mid;
  	if(nums[mid]>value)
  		return BinarySearch(nums,value,mid+1,high);
  		
  		if(nums[mid]<value)
  		return BianrySearch(nums,value,low,mid-1);
  }
  
  ```

- 插值查找

  ```
  插值查找，改变了比例，比如二分查找一定是折半的
  mid=(low+high)/2, 即mid=low+1/2*(high-low);
  但是我们可以自行计算出 一个区间比例值
  将二分之一改成自适应的
  mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，其实这里有点概率论的味道了
  让mid值更靠关键字key 间接减少了比较次数。
  如果数值中如果分布非常不均匀，那么其实和二分查找差不多
  插值查找时间复杂度O(log2log2n)
  
  递归版本
  public int InsertSearch(int nums[],int value,int low, int high){
      int mid=low+(value-nums[low]/nums[high]-nums[low])*(high-low)/2;
      if(nums[mid]==value)
      return mid;
      if(nums[mid]>value)
      return InsertSearch(nums,value,mid+1,high);
      if(nums[mid]<value)
      return InsertSearch(nums,value,low,mid-1);
  }
  ```

  

## 动态规划

- 动态规划与贪心算法的区别

  ```
  动态规划与贪心算法，都是一种递推算法，均有局部最优解来推导全局最优解
  不同：
  贪心算法中，作出的没步贪心决策无法改变，第i天的解必须源自第i-1天，贪心策略是由上一步的最优解推导下一步的最优解，而上一步之前的最优解不作保留。
  
  求最优解问题，从根本上来说是一种对解空间的遍历。
  最直接的暴力分析容易得到，最优解的解空间通常是以指数阶增长，因此无法暴力穷举
  最优解问题大部分问题都可以拆分成一个个的子问题，把解的遍历视为对子树的遍历，则以某种形式对树整个的遍历就可以求出最优解。
  
  贪心是动态规划方法的一个特例，贪心可以在，不需要关注上一步，不需要知道这个节点的所有子树情况就可以求出这个节点的值。
  贪心和动态规划本质上是对子问题树的一种修剪。两种算法要求问题都具有的一个性质就是“子问题最优性”。即，组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的。
  
  动态规划方法代表了这一类问题的一般解法。我们自底向上（从叶子向根）构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。动态规划的代价就取决于可选择的数目（树的叉数）和子问题的的数目（树的节点数，或者是树的高度？）。
  
  贪心与动态规划都是找到最优解，只不过，贪心每一个字问题，子树的根的值与叶子无关，只取决于当前情况，所以不需要知道一个节点所有子树的情况，就可以求出这个节点的值，由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。
  ```

  

  

- 动态规划常用模型

  ```
  
  ```

  

## 图论