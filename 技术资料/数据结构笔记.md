- 给定入栈序列，判断给出的出栈序列可不可能||求出所有的出栈序列||给定树的结点，求有多少种树？

#### 卡特兰数

```
对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。

在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。

不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。

反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。

因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。

显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n-1)=c(2n,n)/(n+1)=h(n)。

还让我们用C++写了当时
```

## 数据结构：

```
基本策略：
1.Leetcode刷题，根据Leetcode给出的题库
2.一天 计网||数据库||多线程编程||Spring相关 换着来 一天一个专题
3.博客也不要拉下，阿里大神的算法博客，多整理笔记，精神高度集中其他课就不看了
4.最后开始看面试70题，面试100题之类的查漏补缺

```



## 编程常用容器类：

- Vector Vector就是队列 可以这么说

  ```Java
  Vector vq= new Vector();
  vq.addElement(months[i]+" ");
  vq.removeElement(vq.firstElement());//先进先出
  ```

  

- List集合去重

  https://www.cnblogs.com/cainiao-Shun666/p/7911142.html

- HashMap如何遍历

  https://blog.csdn.net/gary0917/article/details/79783713

- Java中 List Integer 和int int[]的转换

  <https://blog.csdn.net/zx000003/article/details/82691578>

- 栈Stack

  ```
  Stack底层 用数组，可变数组，链表都可以实现
  ```

## 

## 数组与链表：单/双向链表，跳舞链 //开始刷leetcode

- 单向链表的增删改查
- 









## 栈与队列

## 树与图：最近公共祖先、并查集

- 二叉排序树 和 平衡二叉树

  ```
  二叉排序树和二叉平衡树二叉搜索树 都是一种数据结构
  平衡二叉树的常用算法有红黑树，AVL树等我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。
  最小二叉平衡树的节点的公式如下：
  F(n)=F(n-1)+F(n-2)+1
  真的和斐波那契数列差不多！
  但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
  AVL是第一种被发明的自平衡二叉查找树
  ```

  

- B树

  ```
  B树(B-Tree) 也是一种用于查找的平衡树，但是不是一种二叉树，多叉的。
  这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
  是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
  B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，
  B-树为系统最优化大块数据的读和写操作。
  B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。
  
  在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。
  
  B树作为一种多路搜索树（并不是二叉的）：
  
  　　1) 定义任意非叶子结点最多只有M个儿子；且M>2；
  　　2) 根结点的儿子数为[2, M]；
  　　3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；
  　　4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
  　　5) 非叶子结点的关键字个数=指向儿子的指针个数-1；
  　　6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
  　　7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
  　　8) 所有叶子结点位于同一层；
  　　
  　　首先 定义任意非叶子结点最多只有M个儿子；且M>2；根结点的儿子数为[2,M]；
  　　非根结点的非叶子结点的儿子数为[M/2,M]
  　　对于叶子结点，每个结点存放至少M/2-1 和至多M个关键字
      如下图为一个M=3的B树示例：
  ```

  ![btreebuild](/Users/Haoyu/Desktop/btreebuild.gif)

- B+树

  ```
  B+树是B树的变体，也是一种多路搜索树：
  
  　　1) 其定义基本与B-树相同，除了：
  
  　　2) 非叶子结点的子树指针与关键字个数相同；
  
  　　3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
  
  　　4) 为所有叶子结点增加一个链指针；
  
  　　5) 所有关键字都在叶子结点出现；
  
  　　下图为M=3的B+树的示意图：
  　　B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
  
  　　B+的性质：
  　　1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
  　　2.不可能在非叶子结点命中；
  
  　　3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
  
  　　4.更适合文件索引系统。
  ```

  

  

- 最近公共祖先

  

## 哈希表

- 什么是哈希算法，哈希思想

  ```
  对象的存储位置（或者索引）与对象的关键属性之间形成一个特定的对应关系f(k)
  k关键属性 f(k) 地址空间的一个值，或者再构成一层索引，f()就是哈希函数
  ```

- hash算法，本身可以用作信息安全领域和数据结构领域，一个用作加密，比如MD5，你下载的任何副本的数字指纹只要和官方给出的数据指纹一致，就可以知道这是未经篡改的。例如著名的MD5

- 



## 