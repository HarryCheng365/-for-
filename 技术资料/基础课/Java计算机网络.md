> 1. 自我介绍，说一下最有技术含量的项目

Spring Boot 的 AOP和IOC为核心嘛

比较恶心的有Spring Boot的AOP切面的应用，增删改查方面，分页排序条件查询算一个；然后涉及数据库的，

设计过一个小小的抢票系统，仿照着秒杀做的。

### 因特网的组成

因特网 = 边缘部分 + 核心部分 = 资源子网 + 通信子网

结构如下：

![](../assets/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%901.png)

- 核心部分：让计算机网络能够通讯的部分
- 边缘部分：接到因特网上的计算机

![](../assets/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%902.png)

##### 因特网的边缘部分

主机之间的通讯方式：客户端/服务器方式(Client/Server，CS)，对等方式(Peer-to-Peer，p2p)

- 客户端/服务器方式：客户向服务器请求服务，服务器为客户端提供服务，**这样访问的人越多，网速越慢**。

![](../assets/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%903.png)

- 对等方式（p2p）：每个客户端都可以成为服务器。如常见的p2p下载，第一台客户端向服务器请求资源下载后，自身运行p2p程序，也变成了服务器，其它用户再请求资源下载时，就可以直接从该客户端进行下载。这样情况下，**下载人越多，下载速度越快。**

![](../assets/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%904.png)

##### 因特网的核心部分

​	数据交换的方式：电路交换、报文交换和分组交换。

- 电路交换（Circuit Switching）：原理如下，典型的应用就是打电话，两台电话在需要通信的时候就将它们连起来，不需要通信的时候就将它们的连接释放。

  电路交换面向连接，连接过程为：建立连接（申请占用通信资源） -> 通话（持续占用通信资源） -> 释放连接（释放通信资源）

  不同交换机之间也可以通过中继线连接，交换机与用户之间通过用户线连接，这样就实现了跨交换机长途连接，如从安徽给北京打电话，就需要跨越交换机。

  **电路交换适用于数据量很大的实时性传输**。核心路由之间可能用到电路交换。

![](../assets/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%905.png)

- 分组交换（Packet Switching）：原理即发送端将待发送的信息（报文）进行分段，每一段都额外加上首部，其中包含的数据有地址信息、序号信息等。分段发送到接收端，接收端收到分段信息后，根据首部信息将不同的段落进行组装，最终获取完整的信息。

  **分组交换适用于计算机网络**。

  下图即为分组转发示意图，其中ABCDE为路由器节点，路由器节点具有**存储转发**的功能。

![](../assets/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%906.png)

- 报文交换（Message Switching）：报文交换与分组交换类似，都需要写地址，但报文交换不需要将报文进行分组，而是直接发送。报文交换的时延比较长。

三种发送方式的比较：纵轴为时间轴

![](../assets/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%907.png)

解析：

1. 电路交换方式下是先在ABCD设备间建立连接，之后发送数据，可以看到数据在不同设备之间的传输十分连续快速，最后释放连接。

2. 报文交换方式下，报文从A设备逐个发送到BCD设备，耗时长。

   //要实现有序？所以分组发是一个像串行化的感觉

3. 分组交换方式下，将报文分组，并行传输，十分快速。

# 计算机网络面试问题集锦

## OSI参考模型与TCP/IP参考模型

![img](https://s1.ax1x.com/2018/02/22/9UJf5F.png)

OSI参考模型注重“通讯协议必要的功能是什么”

TCP/IP强调“在计算机上实现协议应该开发哪些程序“

## 应用层

### https

##### 简介

​	https全称为Hyper Text Transfer Protocol Secure，其协议依赖结构与与http协议依赖结构对比如下：

![](../assets/http%E4%B8%8Ehttps.png)

- SSL	

  SSL（Security Sockets layer）安全套接层，是为网络通信提供安全服务及数据完整性的一种协议。其是操作系统对外提供的API，SSL3.0之后更名为TLS(Transport Layer Security，安全传输层协议)。其主要通过身份认证和数据加密来保证网络通信的安全和数据的完整性。

- 加密的方式

  - 对称加密：加密和解密都使用同一个密钥，该算法优点是简单、效率高。
  - 非对称加密：如RSA加密，加密使用的密钥（**公钥**）和解密使用的密钥（**私钥**）是不同的。公钥和算法都是公开的，私钥是保密的。区块链技术采用的就是非对称加密。非对称加密性能较低，加密数据长度有限，但是安全性超强。
  - 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆，如md5加密算法。
  - 数字签名：证明某个消息或者文件是某人发出/认同的，其就是在信息后面加上一段内容，该签内容是经过哈希函数后的值，可以证明该信息没有被修改过。

##### **HTTPS 数据传输流程**

- 浏览器将支持的加密算法信息发送给服务器；
- 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器。证书包含了证书发布的CA机构、证书的有效期、公钥等；
- 浏览器验证证书合法性，并结合证书公钥加密信息发送给浏览器；
- 服务器使用私钥解密信息，验证哈希，加密响应消息回发给浏览器；
- 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据。

注意：公钥是由服务器发送给浏览器！

##### http与https区别

- HTTPS需要到CA申请证书，http不需要；
- HTTPS采用TLS安全传输层协议，是密文传输数据，而HTTP是明文传输数据；
- 连接方式不同，默认使用端口不一样，https 默认使用443端口，HTTP 默认使用80端口；
- HTTPS=HTTP+加密+认证+完整性保护，较http安全。



### http和https的区别 ✅

```
什么是https，说说https的工作原理
Http协议和https都是应用层协议，运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
1.端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
2.资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
3.开销：Https通信需要证书，而证书一般需要向认证机构购买； 
Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。
```

##### 补充：为什么TCP链接需要三次握手，两次不可以么，为什么？✅

```
不可以，考虑一下网络延迟导致的SYN包问题，服务端收到了一个，但是它可能以为这是一个现在的链接请求,于是发送ACK回去。
这时候两次握手和三次握手的区别就出现了。
如果是两次握手，那么ACK发回去后，服务器端就认为是链接已经建立，双方可以通信了，但是实际上是
```

##### 补充：客户端不断进行请求链接会怎么样，DDos攻击？✅

```
就是client一直发请求 但是不确认，缺最后一次握手
DDos预防（没有彻底根治办法，除非不使用Tcp）
  限制同时打开的SYN半链接的数目
  缩短SYN半链接的Time out时间
  关闭不必要的服务，别留那么多服务口？
```

##### 补充：对称加密与非对称加密✅

```
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；

而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密，因此需要知道对方的公钥。
传输用对称加密，因为很快，但是对密钥进行二次加密 采用非对称加密的方式

关于速度问题？
我觉得是算法问题
AES比RSA快1500倍左右，RSA生成一个密钥都要0.6秒左右，更别说完整运行整个加密算法，对报文内容进行加密了。

```

### **谈谈你对http协议的理解✅**

```
Http协议 是web的应用层协议，之所以称为应用层协议，是因为它无需关心数据是通过什么方式到达对端的，只需要协商好使用的数据格式，保证一方可以解析出另一方的意图即可。
Http协议 定义了Web客户机是如何向Web服务器发送
Http协议是无状态的
剩下的话，还可以从URL格式，Http请求报文段，方法名，Http响应报文段来理解Http协议
```

### http报文结构 

##### 请求报文

```
HTTP报文有两种：请求报文和响应报文
1.HTTP请求报文的第一行叫做请求行（Request Line）请求行有3个字段
	方法字段：GET，POST，PUT，DELETE
	URL字段：schema://host[:port]/path/.../[?query-string][#anchor] 锚 内部路由用得到
	HTTP协议版本字段 HTTP/1.1之类的

其后继行叫做首部行（HeaderLine）
如首部行 Connection: close浏览器告诉服务器不希望麻烦地使用持久连接
User-agent 首部行用来定义用户代理 如浏览器
Content-Type：application/x-www-form-urlencoded 指定内容的编码格式
```

##### 响应报文

```
2.HTTP响应报文，Response消息的结构也由三部分组成，初始状态行，六个首部行，实体主题
状态/请求行  然后就是首部行 然后就是实体主体 
状态行： 由协议版本，状态码和相应状态信息组成

首部行：
Connection Date 
Server 
Last-Modified 
Content-Length 
Content-Type 
六个首部行
HTTP报文的结构（一个报文通过套接字下放到TCP连接，对于非持久连接来说，每来一个报文就会开启一个TCP连接，就需要分配相应的缓存和计算资源，就会造成比较大的负载）

HTTP头部（HTTP Request Header 和 HTTP Response Header其实就是首部行
```

### Get与POST的区别✅

##### 功能

##### REST服务上说

##### 请求参数上讲

##### 安全性而言

##### 请求长度而言

```
1.从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
2.从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；
3.从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。
4.就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。
5.从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。
```

### 说说有哪些请求提交方式？✅

```
Get,Post,Head,Options,Put,Delete，但是其实还有更多
Head就像GET 只不过服务端接收到HEAD请求后只返回响应头，而不会发送响应内容。
当我们只需要查看某个页面的状态的时候，使用Head是非常高效的，因为在传输过程中省去了页面内容
```

### http中的状态码都代表什么状态 ✅

```
其实就是http请求中的状态码，状态码分成五大类，范围从100到599
100-199 代表信息性状态码 使用得不多
200-299代表成功状态码 比如200
300-399代表重定向状态码 这些状态码告知客户端要么使用替代的位置访问想要的资源，要么告知服务器可以返回什么来代替资源内容
400-499代表客户端错误状态码
500-599代表服务器错误状态

200 OK: 请求成功，信息包含在返回的响应报文中

301 Moved Permanently: 请求对象已经被永久转移了
302 303 暂时转移 See other: 对应当前请求对响应可以在另一个URL上被找到，而且客户端应当采用Get的方式访问那个资源 

400 Bad Request: 用于告知客户端它发送了一个错误的请求，指示该请求不能被服务器理解。
403 Forbidden: 用于说明请求被服务器拒绝了，拒绝理由可以用实体部分返回描述
404 Not Found:被请求的文档不在服务器上 路径名不对，或者REST接口请求不合规范
405 Method Not Allowed 发起的请求中带有所请求的URL不支持的方法时

500 Internal Server Error: 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码
502 Bad Gateway:
503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可恢复正常
```

### 浏览器请求全部流程

```
当用户在浏览器上输入一段网址后，主要经历了以下过程
1.首先是dns解析，通过域名找到ip地址
2.然后向对应ip地址和端口发送连接请求，服务器接受请求（三次握手）
三次握手完毕后，
3.浏览器发送Http请求报文段
（当然考虑到网络层，是网络层根据TCP协议把包都收完后一起向上提交的）
4.服务器解析Http请求，生成响应报文段，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。
5.浏览器解析Http响应，解析并渲染视图，若遇到对js文件，css文件以及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源，将资源信息显示在屏幕上
6.保持连接或者断开连接，取决于是否开启Keep-alive//断开连接就有4次挥手的过程
```



# 传输层

​	传输层为应用进程之间提供端到端的逻辑通信。目前主要由两个协议，分别是TCP协议和UDP协议。

​	两个对等运输实体在通信时传送的数据单元叫运输协议数据单元。TCP 传输的协议数据单元是TCP报文段，UDP传送的协议数据单元是UDP报文。

### 用户数据协议（UDP）

##### 简介

​	UDP 是User Datagram Protocol的简称， 中文名是**用户数据报协议**，是OSI（Open System Interconnection，开放式系统互联） 参考模型中**一种无连接的传输层协议**，提供面向事务的简单不可靠信息传送服务，但在某些情况下UDP是一种最有效的传输协议。

##### UDP报文组成

![](../assets/UDP%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90.png)

​	注意UDP 添加的首部中没有序号。

```
2字节的源ip地址，端口号 2字节的目的端口号，
2字节长度（包含首部在内的UDP报文段长度），2字节检验和
```

### 输控制协议(TCP)

##### 简介

​	TCP（Transmission Control Protocol，传输控制协议) 是一种面向连接的、可靠的、基于字节流的传输层的协议。TCP传输控制协议：可靠传输协议（ARQ），流量协议和拥塞控制

##### TCP报文组成

```
1.源端口号，目的端口号
2.序号 我产生的序列seq 确认号 期望值
3.首部长度（TCP首部长度是多少，但是由于TCP有选项字段，所以是可变的），ACK FIN 等首部码 状态码 接收窗口（主要用于流量控制）
4.互联网检验和，TCP是有检验和的 紧急数据指针（必须通知接收方的上层实体，我刚才也说了，TCP接受到包后，不是立即提交到）
```

##### TCP 首部详解

​	tcp 首部的格式如下：

![](../assets/TCP%E9%A6%96%E9%83%A8.png)

- 源端口、目标端口：4个字节

- 序号：**表示当前数据包是整个数据的第几个字节**。tcp是将数据分段发送，每一段都包含若干个字节，为了让接收方能正确拼接数据包，需要有序号信息。序号具体为当前数据包的首字节所在的原整个发送文件中的字节序号。如下图所示：

  ![](../assets/tcp%20%E9%A6%96%E9%83%A8%E5%BA%8F%E5%8F%B7.png)

- 确认号：由接收方发送，接收方在收到发送方发送的数据包后，将会给发送方返回一个确认消息，**其中的确认号就表示当前发送方接下来应该发送第几个字节**。如上图中，发送方首先将第一个数据包发送给接收方，接收方收到“1 2 3 4”所在的数据包后，计算得出接下来发送方应该从第五个字节开始发送数据包，此时便会给发送方返回一个确认信息，确认自己收到了“1 2 3 4”数据包，通知发送方应该从第五个字节开始的位置继续发送数据包。

>  确认号是当前收到的，是接收方用于表明已经接受了多少，序列号则根据对方的确认号，确定自己应该从第几个数字开始发送。

- 数据偏移：4位二进制，用来说明tcp数据包从哪里开始时tcp数据部分。因为tcp首部由20字节固定首部和长度可变的选项部分组成，所以需要记录整个tcp首部的长度，不然无法知道数据部分从哪里开始。

  具体的细节：4位二进制的范围是0-15，一个1表示4个字节，所以tcp首部的最长字节是4 x 15 = 60个字节，去掉固定长度20个字节，可变长度最长40个字节。

- 保留：6位2进制，没有用。

- 首部标记位：

  - URG：urgent，表示当前发送数据包比较紧急，不需在发送方的tcp缓存中排队，直接发送，如停止发送命令。
  - PSH：push，与URG相对应，表示当前发送的数据包较为紧急，不需要在接收方的tcp缓存中排队，让接收方优先读取该数据包。
  - ACK：acknowledgement，确认标志，若为0，则表示当前的确认号无效，为1，则表示当前确认号有效。
  - SYN：synchronous，同步标志位，建立请求时会用到，稍后三次握手详解。
  - RST：reset，如果该位取值为1，则表明当前tcp连接出现了严重问题，必须得重新建立连接才能取得正常通信。如点击网页的刷新按钮（异常中断）。
  - FIN：finish，最后数据包传递完，要释放连接，此时 FIN 的值就为1。

- 窗口：通知对方当前接收窗口的大小，让对方设置好发送窗口大小，防止出现连续发送数据包超过接收窗口大小的情况。

- 校验和：校验数据。

- 紧急指针：指明当前需要紧急处理的数据包首部的最后一个字节的位置。

- 选项：可变长度部分内容，有些tcp包有，有些没有，规定一些额外数据。如单个tcp数据包的最大长度（在抓包时可以看到 MISS = 1460，就是这个含义）

- 填充：保证tcp首部字节数是4的倍数。

##### 一个tcp传输实例

​	以下是一个windows xp向一个网站发送请求的真实抓包分析实例：

![](../assets/tcp传输实例.png)

##### 特点

- 面向连接的传输协议
- 全双工 通信两侧即使接收端也是发送端，
- 提供可靠交付服务
- 点对点传输的
- 基于字节流的，一个报文被分割成多个报文段，拼接后，传到上层套接字Socket

##### TCP协议如何来保证传输的可靠性

```
TCP提供一种面向链接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用在彼此交换数据的时候
必须先建立起一个tcp连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序，通过TCP连接交换8bit字节构成的字节流，TCP不在字节流中插入记录标符。

对于可靠性，TCP通过以下方式进行保证
1.数据包校验：校验码 反码相加为1
2.对失序数据包重排序 
3.丢弃重复数据，（丢弃重发，分组流水线重发）
4.应答机制 TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
5.超时重发 TCP发出一个段后，它启动一个定时器，等待目的段确认收到这个报文段

6.流量控制，TCP连接的每一方都有固定大小的缓冲空间，TCP使用的流量控制协议是可变大小的滑动窗口协议
```



##### 可靠传输的实现

ARQ协议：停止等待ARQ和连续ARQ协议，ARQ其实就是自动重新请求，超时重发，只不过一个阻塞一个不阻塞

它使用确认和超时两个机制，来判断数据的丢失并进行重传

​	可靠传输的工作原理——停止等待协议，其工作原理如图：

![](../assets/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png)

​	由图可以看到，无差错情况下发送方和请求方一应一答，如果第一个数据包丢失，发送方会在一个比往返时间（RTT, Round-Trip Time）略长的时间之后再发送数据包。

​	**确认丢失和确认迟到情况的处理：**（出现差错的时候，差错只有两种，丢失和延迟）

![](../assets/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.png)

​	以上的核心是：只要接收方没有告诉发送方已经收到数据包，发送方就认为接收方没有收到，再重新发送数据。**以上的可靠传输协议称为自动重传请求ARQ(Automatic Repeat reQuest)**。ARQ表明重传的请求是自动进行的。 一段时间没有收到ACK就会重传，接收方重复接收后会丢弃，A收到延迟的确认，但是会丢弃

​	停止等待协议的优点是简单，缺点是信道利用率太低。

![](../assets/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png)

​	信道利用率的计算公式如下：
$$
U = \frac{T_D}{T_D + RTT + T_A}
$$
​	其中，Td 是发送时间，RTT是往返时间，Ta 是确认接收时间。

​	由此引入**流水线传输技术**：

![](../assets/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93.png)

​	当前计算机网络中TCP使用的是流水线传输方式，使用协议为**连续ARQ（Automatic Repeat reQuest）协议**。

![](../assets/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.png)

​	由图可见，发送方维持一个发送窗口，此处发送窗口的长度是5，发送方开始时先发送五个数据包，等到第一个数据包确认后，就将发送窗口向右滑动一位，再发下一个数据包（实际实现是将1号数据包从缓存中清除）。

​	但以上流水线传输方式依旧存在问题，就是接收方每接收到一个包就需要返回一个确认信息，效率不高，可采用累积确认改进，即收到连续的包数据时，每隔三个数据包返回一个确认信息，确认信息为收到的第三个数据包的序号，如果中间发生中断，导致接收到的数据包不连续，则就返回中断处前一个接收到的包的序号（如收到1、2、4包，则就返回2）。

##### 

### TCP的链接管理

传输连接有三个阶段：建立连接、数据传送、连接释放。

TCP的连接建立都采用**客户服务机方式**，主动发起连接建立的应用进程叫客户（Client），被动等待连接建立的应用进程叫服务器（Server）。

##### **连接--三次握手**



![](../assets/tcp%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

过程详解：

1. 客户端先向服务器发送一个同步请求，其中SYN 同步标记位标记为1，ACK确认标志标记为0（因为没有确认号），序号为随便的一个数字x。

2. 服务器接受到客户端发起的同步请求，返回一个同步响应，其中SYN同步位标记位1，ACK确认标志标记位1，ack确认号就为x+1，序号为自己随机生成的一个数字y。

3. 客户端收到服务器的同步响应，发送一个确认响应，其中ACK确认标志位为1，ack确认号为y+1，seq序号为x+1。其实例如下图所示：

   ![](../assets/tcp 三次握手实例.png)



##### 释放--四次挥手

- 原理图如下：

  ![](../assets/tcp4%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

- 过程详解：

  ​	数据传输结束后，通信的双方都可以释放连接，现在假设客户A的应用进程先发出tcp释放报文段，并停止发送数据，主动关闭tcp连接。

  1. A 将设置tcp首部FIN标志位为1，seq序号为u，等待B确认；**客户端停止发送数据**
  2. B发出确认，确认号ack = u + 1，seq = v；此时，TCP服务器进程通知高层应用进程，从A到B这个方向的连接就释放了，TCP 连接处于半关闭状态。B若发送数据，A仍要接收。**注意这一步仍然在发送数据**。
  3. 若B已经没有要向A发送的数据，其应用进程就通知TCP服务器进程释放连接。此时设置 TCP 报文首部的FIN=1，ACK = 1，seq = w， ack = u + 1；**close-wait过后 服务器端停止发送数据**  进入Last-ACK状态，就缺客户端再来一个ACK
  4. A给B返回一个响应，TCP报文首段设置ACK = 1， ack = w + 1，seq = u + 1。

  经过以上四个步骤，客户端会再等两个MSL(Maximum Segment Lifetime, 报文最长存活时间)时间，之后双方彻底断开连接。

### 三次握手与四次挥手 ✅

```
比较简单 过程比较容易描述
一般是先由client端发一个FIN码，用来关闭，这时候server进入close——wait状态 
然后服务端发一个ACK=FIN seq+1 作为回复，
之后服务端再发送一个FIN码 用来关闭Server-Client的数据传输
```



### TCP和UDP的区别

```
TCP和UDP都是传输层（运输层）的协议
1.TCP是面向连接的，UDP是无连接的
2.TCP是可靠的，UDP是不可靠的
3.TCP只支持点对点通信（其实本质还是TCP是面向连接的有关），
UDP支持一对一，一对多，多对一，多对多的通信模式
4.TCP是面向字节流的，UDP是面向报文的//TCP面向字节流 
收发双方都会有一个本地tcp缓存，使用tcp协议收发数据时，发送方会将本地待发送文件中的若干个字节复制到本地tcp缓存中，在缓存中进行添加首部等处理，然后发送到接收方的的tcp缓存中，接收方再去除首部，拼装数据到本地存储。
5.TCP拥有拥塞控制机制；UDP没有拥塞控制机制，适合媒体通信
6.TCP首部开销（20个字节）比UDP的首部开销（8个字节）要大
```

### TCP拥塞处理✅

​	前面内容为tcp的传输流量控制（即通过停止等待协议和滑窗技术保证让发送方的发送速率不要太快，让接收方来得及接受），接下来为tcp的拥塞控制。

- 什么是拥塞

  大量的数据发送超过了带宽能承受的范围导致网络变慢。拥塞是一个全局性过程，涉及到所有的主机、所有的路由器，以及降低网络传输性能的所有有关因素。

- 出现拥塞的条件

  对资源需求的总和 > 可用资源。如宽带一共50M，同一时间内出现大量的数据包收发，导致1s内发送的数据量大于50M，此时就出现拥塞。

- 拥塞控制与流量控制的区别

  - 资源拥塞是一个全局性过程，涉及到所有的主机、所有的路由器，以及降低网络传输性能的所有有关因素。
  - 流量控制往往指在给定的发送端和接收端之间点对点的流量控制，所要做的就是抑制发送端的流量发送速率，以便使接收端来得及接收。

- 拥塞控制的作用

  ![](../assets/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png)

- 实现原理：拥塞窗口（慢开始算法、拥塞避免、快重传、快恢复）

  ​	发送方维持拥塞窗口cwnd(congestion window)，拥塞窗口的原则是：只要网络没有出现拥塞，发送窗口就再大一些，以便同时发送更多的包；只要网络出现拥塞，就缩小发送窗口，减少同时发出的包。

  ​	如下所示：

  - **慢开始与拥塞避免**：发送方和接受方两者之间才开始发送数据时，发送方先发一个包，如果接收方的返回结果显示一个包没丢，发送方就增大拥塞窗口，一次发送两个，若接收方返回结果显示一个包没丢，发送方就再增大拥塞窗口，一次发送四个，以此类推...

    ![](../assets/%E6%85%A2%E5%BC%80%E5%A7%8B%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.png)

    慢开始算法有一个**慢开始门限**，门限之前拥塞窗口是指数级增加，到慢开始门限后就一个一个增加，如下图所示：

    ![](../assets/%E6%85%A2%E5%BC%80%E5%A7%8B%E9%97%A8%E9%99%90.png)

    本图中慢开始门限是16，到达16后拥塞窗口每次加一。注意在拥塞窗口到达24时时，出现网络拥塞，此时重新开始慢开始算法，并且将慢开始门限调整为12。

  - **拥塞避免**

    上图已经展示了拥塞避免过程，即在拥塞避免阶段，将拥塞窗口控制为按线性规律增长，使得网络比较不容易出现拥塞。

  - **慢开始与快重传、快恢复**

    接收方丢包时，立马回复丢包信息（连续发三个丢包信息，发送方通过接收到的数量来判断网有没有堵），让发送方重新发送，而不是按照约定的每隔五个包发送一次确认信息，等待一组包发完后再给确认哪个数据包丢了。

    ![](../assets/%E5%BF%AB%E9%87%8D%E4%BC%A0.png)

  - **快恢复**

    快恢复相对于慢开始效率要高很多，快恢复就是让拥塞窗口直接达到新的慢开始门限。

滑动窗口协议通过第四部分，发送窗口之外的缓冲区内暂时不允许发送的数据，来进行流量控制，或者说，控制窗口的长度

### TCP流量协议 

连续ARQ，即流水线发送，通常和滑动窗口协议一起使用的，维持一个滑动窗口，收到确认之后，发送窗口往前，而窗口内的都是一起发的



![](/Users/Haoyu/Documents/Notes-For-Interviews/技术资料/assets/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.png)

​	由图可见，发送方维持一个发送窗口，此处发送窗口的长度是5，发送方开始时先发送五个数据包，等到第一个数据包确认后，就将发送窗口向右滑动一位，再发下一个数据包（实际实现是将1号数据包从缓存中清除）。

​	但以上流水线传输方式依旧存在问题，就是接收方每接收到一个包就需要返回一个确认信息，效率不高，可采用累积确认改进，即收到连续的包数据时，每隔三个数据包返回一个确认信息，确认信息为收到的第三个数据包的序号，如果中间发生中断，导致接收到的数据包不连续，则就返回中断处前一个接收到的包的序号（如收到1、2、4包，则就返回2）。

##### 滑动窗口发送窗口

如下图所示，发送窗口中有四个概念：：已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之内）、允许发送但尚未发送的数据（位于发送窗口之内）、发送窗口之外的缓冲区内暂时不允许发送的数据。

##### 滑动窗口接收窗口

接收窗口中也有四个概念：已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）、未按序收到的数据（位于接收窗口之内）、允许的数据（位于接收窗口之内）、不允许接收的数据（位于发送窗口之内）



![滑动窗口](../assets/滑动窗口.png)

##### 窗口特点

（1）凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。

（2）只有当发送方A收到了接收方的确认报文段时，发送方窗口才可以向前滑动几个序号。

（3）当发送方A发送的数据经过一段时间没有收到确认（由超时计时器控制），就要使用回退N步协议，回到最后接收到确认号的地方，重新发送这部分数据。

### TCP长连接 短连接

- 长连接

  所谓长连接，指在一个TCP连接上可以连续发送多个数据包，**在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接**，一般需要自己做在线维持（不发生RST包和四次挥手）。 

  连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）； 

- 短连接

  短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；

  连接→数据传输→关闭连接；

- 应用场景

  ​	**长连接多用于操作频繁（读写），点对点的通讯**，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：**数据库的连接用长连接**， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。

   	**而像WEB网站的http服务一般都用短链接**（http1.0只支持短连接，1.1keep alive 带时间，操作次数限制的长连接），因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。**所以并发量大，但每个用户无需频繁操作情况下需用短连好**；

  ​     在长连接中一般是没有条件能够判断读写什么时候结束，所以必须要加长度报文头。读函数先是读取报文头的长度，再根据这个长度去读相应长度的报文。

### TCP Time-Wait状态 ✅

- 友好： Time-Wait状态是友好的，因为迟发的报文包最多存活maxinum segment lifetime，而Time-wait状态时长两个MSL，所以可以避免收到服务器SYN码后 因网络延迟 迟收到的数据。如果没有Time-Wait状态，可能旧连接的数据会被新连接收到，保证迟来的数据包可以被识别并抛弃。
- 劣势 Time-Wait状态，一个TCP连接不结束依旧会会但是太长的Time-Wait在面对高并发的短连接场景的时候，会有太多的端口占用，导致资源的浪费和连接的失败

##### 问题出现

1. 端口是有限的。高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。
2. 在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。这里有个相对长短的概念，比如，取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高）
  综合这两个方面，持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。同时，这些端口都是服务器临时分配，无法用SO_REUSEADDR选项解决这个问题:(

##### 如何解决

1.不符合解决原则的办法：

​	linux没有在sysctl或者proc文件系统暴露修改这个TIMEWAIT超时时间的接口，可以修改内核协议栈代码中关于这个TIMEWAIT的超时时间参数，重编内核，让它缩短超时时间，加快回收；









# 网络层

偏硬件了，我赌应该面试到的不多

### IP地址的分类

```

```



### 以及IP地址的APR协议

```
APR协议实现了IP地址和物理地址的映射关系

首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：
如果有，就直接将数据包发送到这个MAC地址；
如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。

```



# 面试题

### 网关的作用是什么

​	就是将两个使用不同协议的网络段连接在一起的设备。它的作用就是对两个网络段中的使用不同传输协议的数据进行互相的翻译转换。

​	连接不同网段，进行数据传输。