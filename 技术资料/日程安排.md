## 协议 架构 存储 缓存 安全

## 这就是技术栈 协议 架构 存储 缓存 安全 

大体了解 可以说上来 分布式的话 毕竟 仅仅 计算机网络 操作系统 并发 还是太少，都没得问只能死扣数据结构了

## 必刷题：

#### 模拟

- [134. 加油站](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/gas-station/)

- [146. LRU缓存机制](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/lru-cache/) ✅

  ```
  HashMap + Queue实现，HashMap进行查找值，Queue记录入队出队，Queue中已有的，出队（移除，不尽兴poll）后再进行入队，进而每次选择都可以先进先去，讲Queue头部结点移除，就是效率不太高
  ```

- [202. 快乐数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/happy-number/) ✅

- [289. 生命游戏](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/game-of-life/)

- [371. 两整数之和](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sum-of-two-integers/)  ✅

  ```
  按位求和现在会了
  ```

  

- [412. Fizz Buzz](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/fizz-buzz/) 

#### **数组**

- [152. 乘积最大子序列](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/maximum-product-subarray/)
- [169. 求众数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/majority-element/)
- [189. 旋转数组](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/rotate-array/)
- [217. 存在重复元素](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/contains-duplicate/)
- [283. 移动零](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/move-zeroes/)
- [384. 打乱数组](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/shuffle-an-array/)
- [350. 两个数组的交集 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/intersection-of-two-arrays-ii/)
- [334. 递增的三元子序列](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/increasing-triplet-subsequence/)
- [240. 搜索二维矩阵 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/search-a-2d-matrix-ii/)
- [238. 除自身以外数组的乘积](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/product-of-array-except-self/)

#### **链表**

- [138. 复制带随机指针的链表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/copy-list-with-random-pointer/)

- [141. 环形链表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/linked-list-cycle/) ✅ set.contain 查重

- [148. 排序链表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sort-list/)  ✅

  ```
  两个已经排序好的链表合并排序merge，那叫二路归并排序
  而未排序的链表合并，则需要用快慢指针找到中点并拆分，并且
  一路拆分下去 直到不可分
  还要从最小不可分单位开始，开始 对左右两侧进行merge 有点像树的感觉，对自底而上建树的感觉，后缀的感觉
  ```

  

- [160. 相交链表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/intersection-of-two-linked-lists/) ✅ 交点，快慢指针，到头以后指向另一个开头

- [206. 反转链表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-linked-list/) ✅ 递归反转和空间开销为1的反转

  ```
  迭代，要用一个ListNode开销 记录pre的值 一开始应该设置为null
  递归，就是递归到底层，自底而上 一层层并且规定好每层做什么
  ListNode prev=reversList(head.next);
  head.next.next=head;
  head.next=null;
  怎么传递头结点的问题在我自己设计的时候遇到了
  所以 这里 return prev就是传回头结点。 要考虑递归最后的返回式是什么
  ```

  

- [234. 回文链表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/palindrome-linked-list/) ✅ 这个有点🐂🍺，也是用快慢指针找中点后 reverse

- [237. 删除链表中的节点](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/delete-node-in-a-linked-list/) ✅ 基础题 不解释

- [328. 奇偶链表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/odd-even-linked-list/) ✅ 依旧两个指针，双指针技巧

#### **堆**

- [155. 最小栈](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/min-stack/) ✅
- [215. 数组中的第K个最大元素](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/kth-largest-element-in-an-array/)
- [295. 数据流的中位数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/find-median-from-data-stream/)
- [378. 有序矩阵中第K小的元素](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)
- [347. 前K个高频元素](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/top-k-frequent-elements/)

#### **栈**

- [150. 逆波兰表达式求值](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/evaluate-reverse-polish-notation/) ✅
- [227. 基本计算器 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/basic-calculator-ii/) ✅
- [341. 扁平化嵌套列表迭代器](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/flatten-nested-list-iterator/) ✅

#### **哈希 / Map**

- [171. Excel表列序号](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/excel-sheet-column-number/) ✅
- [454. 四数相加 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/4sum-ii/) ✅
- [380. 常数时间插入、删除和获取随机元素](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/insert-delete-getrandom-o1/) ✅

#### **队列**

- [239. 滑动窗口最大值](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sliding-window-maximum/) ✅

#### **树**

- 二叉树的深度优先搜索和广度优先搜索

  ```
  广度优先搜索：用一个queue来实现 
  public void levelOrderTraversal(ListNode node){
      if(node==null){
      	System.out.println("empty,tree");
      	return;
      	}
      	Queue<Node> queue=new LinkedList<Node>();
      	queue.add(node);
      	while(!queue.isEmpty()){
              ListNode temp=queue.poll();
              if(temp.left!=null)
              queue.add(temp.left);
              if(temp.right!=null)
              queue.add(temp.right);
              
      	}
      	
  }
  ```

  

- 二叉树反转，二叉树对称问题，

  ```
  二叉树反转：就是对于每一棵有子树的树来说，自顶而上的，对所有左右节点进行调换
  二叉树对称问题：就是对于每一棵有子树的树 检测 left树的.right 和 right树的left是否相等，还有left树的.left和right树的.right 值是否相等，是否一起为空
  ```

  

- [230. 二叉搜索树中第K小的元素](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/kth-smallest-element-in-a-bst/) ✅

  ```
  中序遍历，
  然后用一个stack来存值，如果扫描节点数大于k了还是没找到，
  就提前结束递归，一定要清楚，要不要返回值，不搞返回值如何操作，把值存在哪，结束条件是什么，肯定要写在前面
  ```

  

- [236. 二叉树的最近公共祖先](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) ✅

  ```
  这个最近公共祖先问题，就是递归实现，或者叫二叉树的最低公共祖先
  分别
  ```

  

- [297. 二叉树的序列化与反序列化](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) 

  ```
  这个还没做 等待解决
  ```

#### N叉树

- N叉树的层次遍历，有点难度的，一个是遍历，遍历就很简单，用一个队列一加一减就OK了

  一个是逐层打印，逐层打印需要用到，先逐层把孩子全部输入queue中，然后再remove掉父结点

#### **线段树**

- [218. 天际线问题](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/the-skyline-problem/)

#### **排序**

- [179. 最大数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/largest-number/) ✅

  ```
  自定义排序规则，并且这里用到了字符串相加后大小的比较方法：
  String a = String.valueOf(int);
  String b = String.valueOf(int);
  (a+b).compareTo(b+a)
  大于0说明 大
  ==0 相等
  小于0 说明 小
  ```

  

- [324. 摆动排序 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/wiggle-sort-ii/) ✅

#### **二分检索**

- [162. 寻找峰值](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/find-peak-element/)
- [287. 寻找重复数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/find-the-duplicate-number/)
- [315. 计算右侧小于当前元素的个数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

#### **滑动窗口**

- [395. 至少有K个重复字符的最长子串](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

#### **动态规划**

- [124. 二叉树中的最大路径和](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

- [128. 最长连续序列](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-consecutive-sequence/) ✅

- [198. 打家劫舍](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/house-robber/) ✅

- [279. 完全平方数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/perfect-squares/) ✅

  ```
  和凑硬币法一致，区别在于 硬币知道硬币有多少种，而完全平方数，有几个硬币，需要
  然后剩下的 也不用递归，也不用回溯，就直接 遍历用从0到n 求各个状态，然后父状态减去硬币数额 加一 进行比较，看哪个小，注意临界条件即可
  ```

  

- [300. 最长上升子序列](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-increasing-subsequence/)

- [322. 零钱兑换](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/coin-change/) ✅

- [329. 矩阵中的最长递增路径](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

#### **图论**

- [127. 单词接龙](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/word-ladder/)
- [200. 岛屿的个数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/number-of-islands/)
- [207. 课程表](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/course-schedule/)
- [210. 课程表 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/course-schedule-ii/)

#### **数学 & 位运算**

- [136. 只出现一次的数字](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/single-number/)
- [149. 直线上最多的点数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/max-points-on-a-line/)
- [166. 分数到小数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/fraction-to-recurring-decimal/)
- [172. 阶乘后的零](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/factorial-trailing-zeroes/)
- [190. 颠倒二进制位](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-bits/)
- [191. 位1的个数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/number-of-1-bits/)
- [204. 计数质数](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/count-primes/)
- [268. 缺失数字](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/missing-number/)
- [326. 3的幂](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/power-of-three/)

#### **字符串**

- [125. 验证回文串](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/valid-palindrome/) ✅

  ```
  StringBuilder 有 reverse()接口 可以逆转字符串，还有大小写一律转化成s.toLowerCase()接口
  ```

- [131. 分割回文串](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/palindrome-partitioning/) ✅  真nm难 cao 好像事关搜索 没想到这么难

  ```
  深度优先搜索，和验证回文串，没那么难，
  自己用好dfs的递归，其实就是找到一下，然后再重新搜索，再下一个 这样。
  dfs用栈，或者链表 remove(list.size()-1)这样
  bfs用队列，将孩子全部入队，先进先出，所以可以层次遍历
  ```

- [139. 单词拆分](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/word-break/) ✅

  ```
  类似动态规划，由字典拼凑而成，而不是从拆分字符，搜索入手
  // 可以类比于背包问题
          int n = s.length();
          // memo[i] 表示 s 中以 i - 1 结尾的字符串是否可被 wordDict 拆分
          boolean[] memo = new boolean[n + 1];
          memo[0] = true;
          for (int i = 1; i <= n; i++) {
              for (int j = 0; j < i; j++) {
                  if (memo[j] && wordDict.contains(s.substring(j, i))) {
                      memo[i] = true;
                      break;
                  }
              }
          }//是 确实类似背包问题
          return memo[n];
  ```

- [140. 单词拆分 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/word-break-ii/) ✅

  ```
  需要用到 首先检测可不可以分割 有没有解 是个dp问题
  可分割 后 就在set中加入 wordDict的词  
  之后 dfs 深度优先搜索 深度优先搜索 怎么在String上用的？深度优先搜索用栈
  md 人家30行 用个深度优先搜索就解决问题了
  ```

- 93.复原IP地址

  ```
  回溯，剪枝，所谓回溯剪枝，也不是什么高大上的概念，就是遇到不合条件的提前中止递归，这一条通路废弃，这条答案废弃，所以简单期间，不要在返回值上动手脚，只有在相应理想的终点处，添加合适的结果，不然回溯到上一步，需要进行添删已经存入的值
  带回溯的递归，首先递归怎么写的，一层一层挖下去，每层输入是什么
  ```

- [208. 实现 Trie (前缀树)](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/implement-trie-prefix-tree/)

  ```
  TreeNode{
      TreeNode[] children;
      char val;
      boolean isEnd;//看是不是最后一个结点，不然还要遍历整个子结点数组，挺麻烦的，而且是子结点表明这        //也是一个单词
      public TreeNode(char v){
      this.val=v;
      this.isEnd=false;
      this.children=new TreeNode[26];
          
      }
  }
  ```

- [212. 单词搜索 II](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/word-search-ii/)

  ```
  懂了前缀树，这一数据结构，做单词搜索就比较简单了
  ```

- [242. 有效的字母异位词](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/valid-anagram/) ✅

  ```
  依旧用一个26位的等长的数组来存所有 字符出现的情况，有大小写还要注意tolowerCase 
  反正挺简单的，并且数组遍历起来贼快
  ```

- [387. 字符串中的第一个唯一字符](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/first-unique-character-in-a-string/) ✅

  ```
  可以借助hash表，也可以借助hash表的原理
  用一个等长的数组来存
  ```

- [344. 反转字符串](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-string/) ✅

  ```
  很简单，就是swap冒泡排序
  ```

- 无重复字符的最长子串✅

  ```
  用HashSet进行去重，逐个作为开头进行扫描，然后用一个临时的StringBuilder进行append 并且，用Math.max和之前的最长长度进行比较。
  ```

- 最长公共前缀✅

  ```
  拿到题后不要紧张，一定要分析，心态要平和
  最长公共前缀，首先要得到String的最小length，防止在查找的时候越界
  然后讲各个字符串转为char数组，因为考虑到subString 也是返回字符串，要查找，又要copy字符串的值
  然后我写了 一个基本为n^2的算法，不知道有没有更小的，
  ```

- 字符串相乘✅

  ```
  十分有难度的一个 主要是用于大于Integer.MAX_VALUE值的加减，可以用字符串加减乘除来做。
  ```

  

## 数据结构与算法 只要不是傻子应该就可以过

**4.1日程安排**

- Java 多线程与并发 5道 ✅

  1. 如何停止一个线程
  2. 何为线程安全的类
  3. 什么是死锁（DeadLock）？如何分析和避免死锁？
  4. 什么是线程池，如何创建一个线程池
  5. ConcurrentHashMap（弱一致性）

- Java 计算机网络 5道  ✅

  1. http报文结构
  2. TCP拥塞控制 
  3. OSI与TCP参考模型
  4. TCP与UDP报文段结构
  5. 

- Java 数据结构 链表部分做完 ✅

  链表部分基本做完 还有 涉及排序的链表等

  双指针的技巧 一会把剩下的几个题做了

- Java 数据库 5道

  1.数据库事务 事务的特征

  2.事务并发带来的问题 

  3.事务的隔离级别

  4.mysql的事务支持

  5.MyISAM 和 InnoDB的区别

- Java JVM，常用容器，设计原则以及语言特性 基本 ✅

  1.JVM 内存模型

  2.JVM GC机制 

- Java Spring常用框架 5道 ❌

  1.Spring 中IOC的理解

  2.Spring 中AOP的理解

  3.

- Java 前端基础 5道 …❌



```
补充：
1.反码补码的知识
2.java的位运算
3.堆栈 数据结构 与 容器的基本知识
```



##### **4.2日程安排**

- linux系统，使用过的linux命令 

- Java JVM，常用容器，设计原则以及语言特性5道

  1. 单例模式
  2. 类的生命周期 编译 链接 加载 初始化 使用 卸载

  3. 对象的创建过程
  4. 双亲委派模型
  5. 异常机制再了解 一下

- 数据结构 堆 以及 排序算法今天一定要看了，其他高级算法先不说。

- 把4.1没完成的任务完成

- 做计算机网络的作业



##### **4.3日程安排**

- 完成4.2和4.1没完成的任务完成
- JVM部分看完，主要是GC机制那一块还有点东西
- 容器类！ 今天重点是容器类
- 今天上堆 和 排序 和之前的一样 看一下 尤其是comparator的重载



##### **4.5日程安排**

- 完成4.3和4.2没有完成的任务
- 今天动态规划 和 滑动窗口 两个比较难的部分。



##### **4.7日程安排**

- 动态规划与滑动窗口
- 数组与动态数组
- 字符串



##### **4.8日程安排**

- 动态规划与贪心 有什么异同

- 排序算法比较记忆



##### **4.10日程安排**

- 问题很大，目前关于搜索算法方面的 一窍不通✅ 现在会了
- 现在一直在肝数据结构与算法 其他方面的又拉下了
- 今晚上看 Spring Boot相关 以及计算机网络 和 多线程编程的
- 真的 光一个Java String 可以学好几天 各种封装函数 怎么灵活运用✅



##### 4.12日程安排

- 树和hash 两块
- 二叉树的相关操作，除了遍历；还有hash的板块
- 二叉树：运用递归解决二叉树的深度问题



##### **4.14日程安排**

- 7大搜索算法 和剩下的排序算法 搞明白 原理 时间复杂度 空间复杂度 适用场景✅

  搜索算法目前还剩比较高级的数据结构 B树和B+树 这个和索引的关系 还需要再好好看一下

- Java并发编程 线程池，各类锁 ✅

- Java面向对象 JVM剩下的知识看完 

- Java基础，反射机制 ✅ 

  反射机制搞明白了 基本 但是涉及到JVM的类加载 还是要再看一眼

- 然后就是几个有关树的编程题 自己要着重看一下 



##### 4.15日程安排

- 位运算✅
- 还有一个问题，什么是volatile变量✅
- java基础，static类型的 final类型的 创建回收 什么时候 可不可以强制回收 ✅
- 然后就是明天看操作系统 总结一下 ✅
- 然后就是有关树的几个编程题
- 红黑树的插入删除操作
- NOSQL部分 redis 稍微看一下 不用太费力气
- 晚上看 coding the track系列的几个问题。



##### 4.16日程安排

- 数据库的几个问题 再细看一下 ✅

- 多线程编程 这一块假装自己比较熟悉 也要细看 现在只剩下lock对象了吧 还有AQS重写

  对这个容器重写需要哪些重写哪些方法

- 网络部分自己再看一下 网络部分肯定会问的比较简单，然后就准备面试了

- 关于树的几个编程题

- 面试总结，自己的抗压能力，尤其是代码面方面，还是太差，一被面试官问就蒙了

- 练这么多遍有什么用，面试一面就蒙了，连个链表都写不出来？？？？反转链表啊那可是 简单题！

- 我需要休息了，真的休息 我给自己加太多包袱了。不行就放一放 慢慢找



##### 4.17日程安排

- 反码 补码 位运算，各色位运算符 ✅
- 然后解决了位，加减乘除的问题 ✅
- 字符串的问题的整理，以及采用的主要方法，比如26个数组作为统计 不用hashmap ✅
- 以及 前缀树，或者字典树的建立，记住结点是怎么构造的，这是自己新了解的一种树 需要再看一下
- 另外看一下LRU的实现，再了解一下，然后做一下阿里那个并发编程的题目



##### 4.18日程安排

- 并发编程中的 Thread类进行进一步的分析，关于构造线程，可以用继承Thread的方式 ✅

  也可以用implement Runnable接口的方式，并且分析了Runnable接口和Callable接口的区别 ✅

- 并且对synchronized的底层原理，加锁机制，进行进一步的了解 ✅

- 同时对线程池，也有了更细致的概念 ✅

- 同时也对AQS有了更深一步的理解，接下来还要再了解一下线程通信的知识 AQS还要再仔细看一下

- 今天还有一个主要任务就是对JVM进行整理 ✅

- 同时对Spring Boot的框架 以及 NoSQL  有一定了解

- 并且适当了解一些业务场景题

- 最后再整理一遍，二叉树，多叉树，红黑树，二叉搜索树的主要问题，并再看一下题



##### 4.19日程安排

- 多路归并 快排 二分查找（有序查找系列）
- 堆 最大堆 最小堆 红黑树如何插入的
- 2点之后看上面这些  
- 3点之后就什么也不要看了 静待，我准备的已经比较充分了
- 现在主要看 
- gc机制中的分代收集算法，以及方法区中的常量 和 无用的类是如何被回收的
- 然后就是计算机网络中 tcp拥塞控制那一块吧 
- 然后数据库的话 看一下乐观悲观锁的实现 其他也看不了了 

##### 4.20日程安排

- 查漏补缺 堆再看一下 如何实现，如何用的
- 然后就是剑指offer 再看两眼，说不定就碰上了呢 leetcode先不刷了
- 然后就是 容器 再熟悉一下源码 确保自己可以扯



##### **4.22日程安排**

- 可能会问操作系统 

- 同时 Java 容器方面 和 Java多线程方面自己也熟悉一下 

  自己尽可能讲详细一点

- 然后就是剑指offer的题 以及答案 注意一些 题干短 实现起来复杂的题目

- 然后就是一些牛客网提到的业务场景题



##### 4.24日程安排

- 现在的任务就是打牢基础，为秋招和接下来的实习生招聘做准备。
- 一天的时间 大约 项目/code/英语/基础知识 2:2:4:2的比例吧 一天学习十个小时左右，全天。
- code今天的任务就是把剑指offer打牢
- 英语今天要开始，晚上
- 基础知识也是，开始注意一些实际应用，包含Spring的部分



##### 4.26日程安排

- 网络工程作业写完交了
- 英语单词
- 二分搜索 3个题 kill了



##### **4.27日程安排**

- 软测Lab 1&2✅  多写了个3 明天把作业写完 ✅
- 二分搜索 再kill3个题  并且做总结 
- 剑指offer 3个题 之前标记过的
- 英语单词 ✅
- TPO开始 明天是听力时间
- 然后还有软件工程项目 明天开始后台编码



##### 4.28日程安排

- 今天单词务必推进到WordList 5
- 做完软测第三次作业 ✅
- 今天完成xml作业 第四次的 ✅
- 完成4.27的任务



##### **4.29日程安排**

- 这是场持久战，我现在发现了，守得云开见月明，自己要对几块基础再熟悉一下，结合github和自己的资料

  一天一个part 同时不要耽搁其他部分的学习，比如英语，所以每天时间要规划好

  自己之前是菜，只准备了一个多月，现在要准备两三个月试一下，我就不信了，今年只做这两三件事就好了

  越往后，可以写进简历的东西，越少，但含金量绝对不可同日而语，从后台开发往架构转。

- 今天的任务，单词，推进

- 然后 xml的作业 第四次的，也要推进了

- 今天做题方面，就是算法，排序算法方面，然后自己心态一定调整过来，

  有失败，有成功，胜不骄，败不馁

- 今天的日程安排，严格按照 项目/code/基础/英语 2/2/2/4 来划分 一天十个小时学习时间，

  项目 ✅

  code ✅

- 下午2点半-4点半 项目时间 完成后台数据库表的设计 ✅





##### 体悟

我还是存有一丝侥幸的，可不可以没那么努力，可不可以没那么累，可不可以凭借运气，可不可以或许企业就需要我这样的人，但是生活是残酷的，没有百分百的方法，唯有金诚所至，金石为开，才是最保险的方法，万事万物，能凭运气搏一搏最好，平时看起来一样的人，背后不知道付出了多少时间和精力，有多少十年读书无人问的日子。



##### 燃起希望！

两个星期后 再投一波日常实习，反正面起来很快的自己再用半个月，做好充足准备就好了。

其实我现在多多少少觉得日常实习蛮有趣的。

code环节的定位，其实主要是一个是数据结构与算法的巩固和复习，思考清楚再开始编码。再一个就是良好的编码习惯和变量命名习惯，这一点要注意。书籍的话：数据结构与算法书 和 阿里java开发手册，里面的代码规范。

项目环节，就是写作业，印证自己所学的知识。

基础部分就是对设计模式，数据库，网络，并发，操作系统，JVM，框架，缓存等再进一步做复习和了解，其实一科没多长时间。

Java基础层面，再看一遍Effective Java 我觉得这一本就够了

一天少说要code十道才做得完



##### 4.30日程安排

- 上午 就是基础部分，redis 和 数据库放在一起看一下 2个小时 redis没看✅
- 中午准备一下公选考试 ✅
- 下午考完后 敲code/英语 2个小时 ✅  code敲完了
- 今天啃下23树 b树 b+树 红黑树
- 

潜心学习12天！ 12天！ 12天后 托福考完再说投字节新岗位的事



##### 总结

- 基础进一步强化，通过mooc也好 社区也好，基础进一步强化 计算机网络 操作系统 数据库 这三方面

- 并发 其实只是 很小的一部分而已 在整个数据库体系里

- 数据结构与算法进一步强化，分别通过 数据结构 和 算法 两个mooc两个方面

- 框架进一步学习 以及 分布式系统进一步学习 

  协议 框架 存储 缓存 安全 

- 当然 不需要全会 一半以上 就可以找到好的实习了，最关键的是 自己还不知道 要走哪条路，但

  计算机硕士是硬通货 

##### 5.1日程安排

- 今天看一眼redis和Spring 框架的基础 

- 晚上研究一下partition的具体用法，特别对于快排，把那几个类似的题给啃了，看来自己的基础远远不够

  ...也怪不得了 还是自己太菜

  今天的项目 要研究一下Spring框架

- 休息的时候看effective-java

  分布式肯定和拓扑结构以及图论有关系

- 今天再看一眼violate 的可见性和禁止指令重排序，可见性我理解了，其实就是宣布失效，指令重排序自己要理一理

- 不要急，还有机会，5.31才禁止投递呢，这么多岗位

- redis框架看了一半 知道个大概 几个重点应该都清楚了✅

- Spring 还没有看 晚上结合着看一下

- 晚上还要撸代码

| 序号 | 待解决问题                      | 解决情况 |
| ---- | ------------------------------- | -------- |
| 1    | violate指令重排序               |          |
| 2    | 设计模式中的工厂模式            |          |
| 3    | Spring框架开始看看              |          |
| 4    | 堆排序 自己写一个模拟堆排序过程 |          |
| 5    | Effective-Java 笔记             |          |



##### 5.2日程安排

- redis 和 Mysql的底层实现结构看完 2-3树 二叉搜索树 B树 B+树 红黑树 AVL树创建，插入，删除，保持平衡

- 代码方面，剑指所有关于二叉树的，所有关于Partition 分治思想的自己再总结一下。

  晚上两个小时

- 今天挑挑拣拣Effective-Java中的 东西 不需要全部都看 

| 序号 | 待解决问题               | 解决情况 |
| ---- | ------------------------ | -------- |
| 1    | 跳表是如何加速搜索的？   | ✅        |
| 2    | 红黑树的创建 插入 删除？ |          |
| 3    | 什么是鸽笼原理？         |          |
| 4    |                          |          |
| 5    |                          |          |

- 所有类型相同的包装类型比较，全部使用equals方法，这样更可以看到重写hashcode()方法的重要性
- 今天学英语，口语特别是



##### 5.3日程安排

- 明天就主要是 并发部分的温习了，Java并发部分的编程，然后Redis估计看不完，把Redis再解决一下
- 然后明天还有框架部分的东西，今天数据库 明天是并发编程的一天

| 序号 | 待解决问题                                                   | 解决情况  |
| ---- | ------------------------------------------------------------ | --------- |
| 1    | 并发编程的ReentLock ArrayBlockingQueue                       | ✅         |
| 2    | 操作系统的进程线程 调度 死锁的概念                           |           |
| 3    | 找一个JMM重排序的例子，JMM内存模型，再说吧                   |           |
| 4    | 中断和阻塞？是一个东西吗？                                   |           |
| 5    | wait(long timeout, int nanos)? nanos是个啥？                 |           |
| 6    | 看一看AQS state的源码，到底有没有volatile修饰                | ✅ 有      |
| 7    | Thread 只实现了Runnable接口,(new Callable)这种写法是构造函数 | ✅搞明白了 |
|      |                                                              |           |

- 今天剩下的时间，看红黑树 堆 堆排序和Java 容器部分 还是这些问的多

  然后写剑指5个题 剩下时间学英语 

##### 5.4日程安排

| 序号 | 待解决问题                        | 解决情况 |
| ---- | --------------------------------- | -------- |
| 1    | 四次挥手双方所处的状态，复习一下  | ✅        |
| 2    | CountDownLatch的 使用 强化一下    |          |
| 3    | B+树 和 堆排序 看一下             |          |
| 4    | TCP拥塞控制看一下，到底怎么处理的 | ✅        |
| 5    | Effective-Java 看五个题           |          |
| 6    | Redis的五大结构使用               | ✅        |
| 7    | 海量数据类型的整理完毕            |          |
| 8    |                                   |          |

- 晚上剑指offer所有 和树相关的题，都解决掉，包含回溯搜索类型的