## 数据库相关知识：锁，连接池，事务，索引

**基本概念整理： 主属性 主键 超键 候选键等**

https://blog.csdn.net/u013630349/article/details/50724244

**数据库事务：**

```
原子性  事务的原子性是指一个事务要么全部执行，要么不执行。不可能执行一半就停止了，遇到这种情况会回滚rollback

一致性  事务的运行并不改变数据库中数据的一致性，比如a与b之间有某种关系限制，事务改变了a，也势必会改变b

独立性 两个以上的食物不会出现交错执行的状态，因为这样可能导致数据不一致

```

关键码应该是指 唯一标识的主键

- 聚簇索引和非聚簇索引

> B Tree 即 也是一种用于查找的搜索树，但是它不是二叉树

B+Tree InnoDB 存储引擎的索引实现 是B-Tree的变形树

一棵M阶的B+Tree 和M阶的B-Tree的差异在于以下三点

- n棵子树的结点中含有n个关键码

- 所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码的指针

  且叶子结点本身依关键码的大小自小而大的顺序链接；

- 非终端结点也可以看成是索引部分，结点中仅含有其子树根结点中最大（最小）的关键码



![A1C4CC1A-27C9-4AB3-A489-AD233F57933B](/Users/Haoyu/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/582416551/QQ/Temp.db/A1C4CC1A-27C9-4AB3-A489-AD233F57933B.png)

上图显示了一种索引方式。左边是数据库中的数据表，有col1和col2两个字段，一共有15条记录；右边是以col2列为索引列的B_TREE索引，每个节点包含索引的键值和对应数据表地址的指针，这样就可以都过B_TREE在 O(logn) 的时间复杂度内获取相应的数据，这样明显地加快了检索的速度

两者相互独立，比如这个表有col1，col2字段，这就是这个数据表，

但是BTree 需要中序遍历整个表，才可以完成搜索，并且Btree还需要含有相应的关键字

这时候B+Tree 的好处就体现出来了，





## 相关面试问题：

> 索引相关

- Mysql索引的种类？✅

  ```
  1.聚簇索引和非聚簇索引
  聚簇索引的顺序就是数据的物理存储顺序；
  索引顺序与数据物理排列顺序无关。
  因此 一个表最多有一个聚簇索引，聚簇索引的叶结点就是数据节点，而非聚簇索引的叶结点仍然是索引节点，只不过有一个指针指向对应的数据块。
  聚簇索引确定表中数据的物理顺序，聚簇索引对于那些经常要搜索范围值的列特别有效。使用聚簇索引找到包含第一个值的行后，便可以确保后续索引值的行物理相邻。
  非聚簇索引，索引中的项目按索引键值的顺序存储，而表中的信息按另一种顺序存储。
  2.普通索引和唯一索引
  索引列的值的唯一性 比如主键就是唯一索引的特殊类型，创建主键的时候，数据库默认会为主键创建一个唯一索引
  3.单个索引和复合索引（或者组合索引）
  索引列包含的列数
  ```

- Mysql B+树？

  ```
  B+树的性质：
  所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；
  非终端结点可以看成是索引部分，节点中仅含有其子树根结点中最大（或最小）关键码
  ```

- 数据库索引为什么用b+树

  ```
  B+树相对于B树来说，
  1.B+tree的磁盘读写代价更低，因为所有的信息都在叶子节点存着，并且叶子结点之间还以链表的形式互相连接
  B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。
  一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；
  2.B+ Tree的查找效率更加稳定，由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。
  所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；
  3.数据库索引采用B+树，而不是B树的主要原因是，对于涉及范围的查找，或者说需要对整个树进行遍历，B+树只需对链表进行遍历，而B树需要中序遍历才行。
  ```

- 索引的好处✅  以及什么样的字段适合创建索引？

  ```
  大大加快数据的检索速度，这也是创建索引的最主要的原因；
  加速表和表之间的连接
  使用分组和排序子句进行数据检索的时候，同样可以显著减少查询中分组和排序的时间
  通过创建唯一性的索引，在插入表的时候，比如主键就是唯一索引，数据库会为主键默认的创建一个唯一索引
  
  答：
  1.首先肯定是，经常作查询选择的字段。
  2.经常作表连接的字段
  3.经常出现在order by，group by，distinct的字段后面
  ```

- 什么情况下不使用索引	✅

  ```
  1.时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
  2.空间方面：索引需要占物理空间。
  因此我觉得不使用索引的情况，是数据量并没有想象那么大，创建和维护索引（增删改频繁）相对来说开销较大的时候。
  再一个就是，比如我本身的任务就是遍历，检索所有数据，将所有数据读出来，用索引反而要先扫描索引再去扫描所有界面，就有点多余了。
  ```

- mysql复合（组合、联合）索引，最左匹配原则✅

  ```
  对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。
  ```

- mysql索引失效✅

  ```
  1.以“%(表示任意0个或多个字符)”开头的LIKE语句，模糊匹配；
  2.OR语句前后没有同时使用索引；
  3.数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；
  4.对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。按次，先根据第一个关键字来筛选嘛，所以就出现了最左匹配的原则。
  ```

- mysql在没有索引的情况下如何快速查询

  ```
  mysql在没有索引的情况下想达到快速查询
  ```

- sql优化



- B+Tree： 是InnoDB引擎的索引实现，不同的引擎正如不同版本的虚拟机

> 连接池相关

- 数据库连接池，如果开发中使用连接池发现可用连接数量不足，可能是什么原因？







> 数据库事务

- 事务是什么

  ```
  1. 事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行结果必须使数据库从一种一致性的状态变到另一种一致性的状态。
  ```

- 事务的特征

  ```
  
  ```

  

- 事务并发带来的问题

  ```
  脏读：一个事务读取了另一个事务未提交的数据，即一个事务读取了另一个事务正在修改的值，已经改变的值
  不可重复读：不可重复读的重点是修改，同时条件下两次读取结果不同，也就是说被读区的数据可以被其他事务修改
  幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样
  ```

- 数据库事务的隔离级别

  ```
  
  ```

  

> 数据库锁相关

- 数据库乐观锁和悲观锁是什么，实现？