# Java知识结构

>  最快的方法掌握所有基本技术

# 基础知识

> 先处理几个Java高级面试板块

# 首先自我介绍类

> 1. 自我介绍，说一下最有技术含量的项目

Spring Boot 的 AOP和IOC为核心嘛

比较恶心的有Spring Boot的AOP切面的应用，增删改查方面，分页排序条件查询算一个；然后涉及数据库的，

设计过一个小小的抢票系统，仿照着秒杀做的。

# 计算机网络面试问题集锦

## 应用层

#### 三次握手与四次挥手✅

```
比较简单 过程比较容易描述
一般是先由client端发一个FIN码，用来关闭，这时候server进入close——wait状态 
然后服务端发一个ACK=FIN seq+1 作为回复，
之后服务端再发送一个FIN码 用来关闭Server-Client的数据传输
```



#### http和https的区别 ✅

```
什么是https，说说https的工作原理
Http协议和https都是应用层协议，运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
1.端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
2.资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
3.开销：Https通信需要证书，而证书一般需要向认证机构购买； 
Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。
```

##### 补充：为什么TCP链接需要三次握手，两次不可以么，为什么？✅

```
不可以，考虑一下网络延迟导致的SYN包问题，服务端收到了一个，但是它可能以为这是一个现在的链接请求,于是发送ACK回去。
这时候两次握手和三次握手的区别就出现了。
如果是两次握手，那么ACK发回去后，服务器端就认为是链接已经建立，双方可以通信了，但是实际上是
```

##### 补充：客户端不断进行请求链接会怎么样，DDos攻击？✅

```
就是client一直发请求 但是不确认，缺最后一次握手
DDos预防（没有彻底根治办法，除非不使用Tcp）
  限制同时打开的SYN半链接的数目
  缩短SYN半链接的Time out时间
  关闭不必要的服务，别留那么多服务口？
```

##### 补充：对称加密与非对称加密✅

```
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；

而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密，因此需要知道对方的公钥。
传输用对称加密，因为很快，但是对密钥进行二次加密 采用非对称加密的方式

关于速度问题？
我觉得是算法问题
AES比RSA快1500倍左右，RSA生成一个密钥都要0.6秒左右，更别说完整运行整个加密算法，对报文内容进行加密了。

```

#### **谈谈你对http协议的理解✅**

```
Http协议 是web的应用层协议，之所以称为应用层协议，是因为它无需关心数据是通过什么方式到达对端的，只需要协商好使用的数据格式，保证一方可以解析出另一方的意图即可。
Http协议 定义了Web客户机是如何向Web服务器发送
Http协议是无状态的
剩下的话，还可以从URL格式，Http请求报文段，方法名，Http响应报文段来理解Http协议
```

#### http报文结构 

##### 请求报文

```
HTTP报文有两种：请求报文和响应报文
1.HTTP请求报文的第一行叫做请求行（Request Line）请求行有3个字段
	方法字段：GET，POST，PUT，DELETE
	URL字段：schema://host[:port]/path/.../[?query-string][#anchor] 锚 内部路由用得到
	HTTP协议版本字段 HTTP/1.1之类的

其后继行叫做首部行（HeaderLine）
如首部行 Connection: close浏览器告诉服务器不希望麻烦地使用持久连接
User-agent 首部行用来定义用户代理 如浏览器
Content-Type：application/x-www-form-urlencoded 指定内容的编码格式
```

##### 响应报文

```
2.HTTP响应报文，Response消息的结构也由三部分组成，初始状态行，六个首部行，实体主题
状态/请求行  然后就是首部行 然后就是实体主体 
状态行： 由协议版本，状态码和相应状态信息组成

首部行：
Connection Date 
Server 
Last-Modified 
Content-Length 
Content-Type 
六个首部行
HTTP报文的结构（一个报文通过套接字下放到TCP连接，对于非持久连接来说，每来一个报文就会开启一个TCP连接，就需要分配相应的缓存和计算资源，就会造成比较大的负载）

HTTP头部（HTTP Request Header 和 HTTP Response Header其实就是首部行
```

#### Get与POST的区别✅

##### 功能，REST服务上说，请求参数上讲，安全性而言，请求长度而言

```
1.从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
2.从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；
3.从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。
4.就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。
5.从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。
```

#### 说说有哪些请求提交方式？

```
Get,Post,Head,Options,Put,Delete，但是其实还有更多
Head就像GET 只不过服务端接收到HEAD请求后只返回响应头，而不会发送响应内容。
当我们只需要查看某个页面的状态的时候，使用Head是非常高效的，因为在传输过程中省去了页面内容
```

#### http中的状态码都代表什么状态

```
其实就是http请求中的状态码，状态码分成五大类，范围从100到599
100-199 代表信息性状态码 使用得不多
200-299代表成功状态码 比如200
300-399代表重定向状态码 这些状态码告知客户端要么使用替代的位置访问想要的资源，要么告知服务器可以返回什么来代替资源内容
400-499代表客户端错误状态码
500-599代表服务器错误状态

200 OK: 请求成功，信息包含在返回的响应报文中

301 Moved Permanently: 请求对象已经被永久转移了
302 303 暂时转移 See other: 对应当前请求对响应可以在另一个URL上被找到，而且客户端应当采用Get的方式访问那个资源 

400 Bad Request: 用于告知客户端它发送了一个错误的请求，指示该请求不能被服务器理解。
403 Forbidden: 用于说明请求被服务器拒绝了，拒绝理由可以用实体部分返回描述
404 Not Found:被请求的文档不在服务器上 路径名不对，或者REST接口请求不合规范
405 Method Not Allowed 发起的请求中带有所请求的URL不支持的方法时

500 Internal Server Error: 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码
502 Bad Gateway:
503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可恢复正常
```

#### 浏览器请求全部流程

```
当用户在浏览器上输入一段网址后，主要经历了以下过程
1.首先是dns解析，通过域名找到ip地址
2.然后向对应ip地址和端口发送连接请求，服务器接受请求（三次握手）
三次握手完毕后，
3.浏览器发送Http请求报文段
（当然考虑到网络层，是网络层根据TCP协议把包都收完后一起向上提交的）
4.服务器解析Http请求，生成响应报文段，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。
5.浏览器解析Http响应，解析并渲染视图，若遇到对js文件，css文件以及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源，将资源信息显示在屏幕上
6.保持连接或者断开连接，取决于是否开启Keep-alive//断开连接就有4次挥手的过程
```

## OSI参考模型与TCP/IP参考模型

![img](https://s1.ax1x.com/2018/02/22/9UJf5F.png)

OSI参考模型注重“通讯协议必要的功能是什么”

TCP/IP强调“在计算机上实现协议应该开发哪些程序“

## 传输层

#### TCP协议如何来保证传输的可靠性

```
TCP提供一种面向链接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用在彼此交换数据的时候
必须先建立起一个tcp连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序，通过TCP连接交换8bit字节构成的字节流，TCP不在字节流中插入记录标符。
对于可靠性，TCP通过以下方式进行保证
1.数据包校验：校验码 反码相加为1
2.对失序数据包重排序 
3.丢弃重复数据
4.应答机制 TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
5.超时重发 TCP发出一个段后，它启动一个定时器，等待目的段确认收到这个报文段
6.流量控制，TCP连接的每一方都有固定大小的缓冲空间，TCP使用的流量控制协议是可变大小的滑动窗口协议
```

#### TCP和UDP的区别

```
TCP和UDP都是传输层（运输层）的协议
1.TCP是面向连接的，UDP是无连接的
2.TCP是可靠的，UDP是不可靠的
3.TCP只支持点对点通信（其实本质还是TCP是面向连接的有关），
UDP支持一对一，一对多，多对一，多对多的通信模式
4.TCP是面向字节流的，UDP是面向报文的//TCP面向字节流 
5.TCP拥有拥塞控制机制；UDP没有拥塞控制机制，适合媒体通信
6.TCP首部开销（20个字节）比UDP的首部开销（8个字节）要大
```

#### UDP报文结构

```
2字节的源ip地址，端口号 2字节的目的端口号，
2字节长度（包含首部在内的UDP报文段长度），2字节检验和
```

#### TCP报文结构

```
1.源端口号，目的端口号
2.序号 我产生的序列seq 确认号 期望值
3.首部长度（TCP首部长度是多少，但是由于TCP有选项字段，所以是可变的），ACK FIN 等首部码 状态码 接收窗口（主要用于流量控制）
4.互联网检验和，TCP是有检验和的 紧急数据指针（必须通知接收方的上层实体，我刚才也说了，TCP接受到包后，不是立即提交到）

```

#### TCP拥塞处理✅

```
计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。

拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。
注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。
拥塞控制的方法主要有以下四种：
1.慢启动：不要一开始就发送大量数据，先探测一下网络的拥塞成都，也就是说由校到大主键增加拥塞窗口大大小
2.拥塞避免：拥塞避免算法能让拥塞
```



## IP地址的分类

```

```



#### 以及IP地址的APR协议

```
APR协议实现了IP地址和物理地址的映射关系

首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：
如果有，就直接将数据包发送到这个MAC地址；
如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。

```



