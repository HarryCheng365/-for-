## 操作系统基本概念

稍微看一下

进程

线程

进程管理：

内存管理：

## 进程与线程的区别：

![2835CD58-5BE6-45DA-BB71-AB3B4DD92309](/Users/Haoyu/Desktop/2835CD58-5BE6-45DA-BB71-AB3B4DD92309.png)

- 进程与线程的区别

  首先进程是程序的一次执行，包含代码和数据

  是资源分配的基本单位

  而子进程可以是父进程的复制品，可以获得父进程的数据空间、堆、栈的复制品，linux的fork

  

  线程是进程的一个执行单元

  是调度和执行的基本单位，是比进程更小的独立运行单位

- 进程和线程的区别？

  ```
  1.一个进程可以有多个线程，多个线程可以并发，可以共享进程数据，拥有自己独立的栈空间和执行序列。
  2.进程与线程是不同的系统资源管理方式。进程拥有独立的地址空间，而线程没有。一个进程崩溃后，在保护模式下，不会对其他进程造成影响；
  3.而线程只是进程的一个执行路径，没有自己独立的地址空间，一旦一个线程崩溃，整个进程就会崩溃。所以，多进程的程序比多线程程序更加健壮。
  4.线程不占用系统资源，调度线程比调度进程开销更小，在线程间切换比在进程间切换效率高。
  5.对于一些要求同时进行而又共享某些变量的并发操作来说，只能用多线程，不能用多进程。
  
  同时进行而又要共享变量，有共享区，共享一些值，所以说只能用多线程，不能用多进程。
  
  ```

- Java里并发的实现机制都是同步互斥访问，但是其实线程同步的方法有很多

  ```
  1.互斥(信号)量，每个时刻只有一个线程可以访问公共资源。只有拥有互斥对象的线程才能访问公共资源，互斥对象只有一个，一个时刻只能有一个线程持有，所以保证了公共资源不会被多个线程同时访问。
  2.信号量，允许多个线程同时访问公共资源。当时控制了访问资源的线程的最大个数。
  3.事件 in windows（条件变量 in linux）。通过通知的方式保持多线程的同步，还可以方便的实现多线程优先级的比较
  4.临界区。任意时刻只能有一个线程进入临界区，访问临界资源。
  ```

  

  进程同步的方法也很多

  ```
  原子操作（互斥，要么都改要么都不改）
  信号量
  管程
  ```

- 进程有几种状态

  ```
  新建进程->加载->就绪，调度，运行 执行完了：释放 等待IO：阻塞 时间片用完:就绪 阻塞后 可以被唤醒notify() 到就绪状态
  ```

- 进程创建过程

  ```
  给新进程分配一个唯一的标识符
  给进程分配内存空间
  初始化进程控制块PCB：进程存在的唯一标识
  将PCB放入就绪队列中，等待分配CPU资源
  ```

- 

## CPU调度算法（其实是进程的调度算法）：

## 先来先服务调度算法(FCFS)

- 最简单的调度算法



## 优先级算法(Priority)



## 时间片轮转法



## 多级队列法





## 内存管理

- CPU通过MMU（界限地址寄存器和重定位寄存器，和数组差不多，基地址+指针）

- 概述

  ```
  固定分区，将内存分为多个固定大小的分区，每个分区只能容纳一个进程，因此多道程序的，
  动态分区，
  再一个还有个适配的解决方案
  1.首次适应
  2.最佳适应
  3.最差适应
  无论是固定分区还是动态分区，都会存在内存碎片的问题，分区的解决方案，无论是内部碎片还是外部碎片
  ```

- 

## 页调度算法：

## FIFO 先进先出调度算法

没什么好说的 

## LRU 最近最少使用调度算法

- 调入也算调用一次
- 相同使用次数，替换掉最近的
- 没有其实不统计历史使用次数，就替换掉存在在cache空间里的最少使用的页